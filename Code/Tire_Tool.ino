//<App !Start!>
// FILE: [TireToolFinal.ino]
// Created by GUIslice Builder version: [0.16.b004]
//
// GUIslice Builder Generated File
//
// For the latest guides, updates and support view:
// https://github.com/ImpulseAdventure/GUIslice
//
//<App !End!>

// ------------------------------------------------
// Headers to include
// ------------------------------------------------
#include "TireToolFinal_GSLC.h"
#include "SD.h"
#include "Adafruit_AMG88xx.h"
Adafruit_AMG88xx amg;
#include "RTClib.h"
RTC_DS1307 rtc;
#include "SparkFun_MCP9600.h"
MCP9600 probe;
#include "Honeywell_ABP.h"
Honeywell_ABP abp(0x28,0,60,"psi");


// ------------------------------------------------
// Program Globals
// ------------------------------------------------
bool pauseTemp = false;
bool pausePressure = false;
unsigned long screensaverTimer;
unsigned long refreshTimer;
unsigned long currentMillis;
const uint16_t Minutes = 60000;
const uint8_t Halfseconds = 500;
uint8_t lastPageId = PG_Home;

// ------------------------------------------------
// Temperature Probe Globals
// ------------------------------------------------
char  tempBuf [8];
int16_t gaugeVal;
float   probeTemp;


// ------------------------------------------------
// Pressure Gauge Globals
// ------------------------------------------------
char  pressureBuf [8];
float    gaugePressure;
float    sensorPressure;


// ------------------------------------------------
// Data Log Globals
// ------------------------------------------------
char   logTemp[5];
char   logFolder[MAX_STR];
char   logName[MAX_STR];
char   logPath[MAX_STR];
char   LogInfoBuf [MAX_STR];
char   averageBuf [7];
char   deltaBuf [MAX_STR];
char   trackTempBuf [MAX_STR];
char   ambTempBuf [MAX_STR];
const char* dateBuf;
static char nullnullval[7] = "---.--";
const uint8_t   Left = 0;
const uint8_t   Rear = 1;
const uint8_t   Right = 2;
const uint8_t   Front = 3;
const uint8_t   FrontLeft = 0;
const uint8_t   RearLeft = 1;
const uint8_t   RearRight = 2;
const uint8_t   FrontRight = 3;
const uint8_t   numberLogLines (15);
int8_t  ambTemp;
int8_t  counter = -1;
int16_t  dataFieldInt [12];
int16_t  cornerAverage [4];
int16_t  cornerHighTemp[4];
int16_t  cornerLowTemp[4];
float  cornerDelta [4];
float  sideAverage [4];


// ------------------------------------------------
// Thermal Camera Globals
// ------------------------------------------------
#define AMG_COLS 8
#define AMG_ROWS 8
bool pauseThermal = false;
bool autoScale = false;
bool cursorOn = true;
bool DefaultTemp = true;
char  scaleRangeBuf[3];
char  minTempBuf [3];
char  maxTempBuf [3];
char  cursorTempBuf [5];
int8_t  MINTEMP = 20;
int8_t  MAXTEMP = 30;
uint8_t  thermalCol;
uint8_t  thermalSel;
uint8_t  scaleRange = 4;
uint8_t  INTERPOLATED_COLS = 36;
uint8_t  INTERPOLATED_ROWS = 36;
uint8_t  boxWidth = 7;
uint8_t  boxHeight = 5;
uint8_t  red, green, blue;
uint16_t   colorMap;
float  colorTemp;
float  cursorTemp;
float  pixels[AMG_COLS * AMG_ROWS];
float  dest_2d[3780]; //array size must match the largest number of rows * columns that can be encountered during runtime
float  get_point(float *p, uint8_t rows, uint8_t cols, int8_t x, int8_t y);
float  cubicInterpolate(float p[], float x);
float  bicubicInterpolate(float p[], float x, float y);
void set_point(float *p, uint8_t rows, uint8_t cols, int8_t x, int8_t y, float f);
void get_adjacents_1d(float *src, float *dest, uint8_t rows, uint8_t cols, int8_t x, int8_t y);
void get_adjacents_2d(float *src, float *dest, uint8_t rows, uint8_t cols, int8_t x, int8_t y);
void interpolate_image(float *src, uint8_t src_rows, uint8_t src_cols, float *dest, uint8_t dest_rows, uint8_t dest_cols);



const uint32_t colorPallete [][433] = {

  //IRONBOW
  { 0x00000a, 0x000014, 0x00001e, 0x000025, 0x00002a, 0x00002e, 0x000032, 0x000036, 0x00003a, 0x00003e, 0x000042,
    0x000046, 0x00004a, 0x00004f, 0x000052, 0x010055, 0x010057, 0x020059, 0x02005c, 0x03005e, 0x040061, 0x040063,
    0x050065, 0x060067, 0x070069, 0x08006b, 0x09006e, 0x0a0070, 0x0b0073, 0x0c0074, 0x0d0075, 0x0d0076, 0x0e0077,
    0x100078, 0x120079, 0x13007b, 0x15007c, 0x17007d, 0x19007e, 0x1b0080, 0x1c0081, 0x1e0083, 0x200084, 0x220085,
    0x240086, 0x260087, 0x280089, 0x2a0089, 0x2c008a, 0x2e008b, 0x30008c, 0x32008d, 0x34008e, 0x36008e, 0x38008f,
    0x390090, 0x3b0091, 0x3c0092, 0x3e0093, 0x3f0093, 0x410094, 0x420095, 0x440095, 0x450096, 0x470096, 0x490096,
    0x4a0096, 0x4c0097, 0x4e0097, 0x4f0097, 0x510097, 0x520098, 0x540098, 0x560098, 0x580099, 0x5a0099, 0x5c0099,
    0x5d009a, 0x5f009a, 0x61009b, 0x63009b, 0x64009b, 0x66009b, 0x68009b, 0x6a009b, 0x6c009c, 0x6d009c, 0x6f009c,
    0x70009c, 0x71009d, 0x73009d, 0x75009d, 0x77009d, 0x78009d, 0x7a009d, 0x7c009d, 0x7e009d, 0x7f009d, 0x81009d,
    0x83009d, 0x84009d, 0x86009d, 0x87009d, 0x89009d, 0x8a009d, 0x8b009d, 0x8d009d, 0x8f009c, 0x91009c, 0x93009c,
    0x95009c, 0x96009b, 0x98009b, 0x99009b, 0x9b009b, 0x9c009b, 0x9d009b, 0x9f009b, 0xa0009b, 0xa2009b, 0xa3009b,
    0xa4009b, 0xa6009a, 0xa7009a, 0xa8009a, 0xa90099, 0xaa0099, 0xab0099, 0xad0099, 0xae0198, 0xaf0198, 0xb00198,
    0xb00198, 0xb10197, 0xb20197, 0xb30196, 0xb40296, 0xb50295, 0xb60295, 0xb70395, 0xb80395, 0xb90495, 0xba0495,
    0xba0494, 0xbb0593, 0xbc0593, 0xbd0593, 0xbe0692, 0xbf0692, 0xbf0692, 0xc00791, 0xc00791, 0xc10890, 0xc10990,
    0xc20a8f, 0xc30a8e, 0xc30b8e, 0xc40c8d, 0xc50c8c, 0xc60d8b, 0xc60e8a, 0xc70f89, 0xc81088, 0xc91187, 0xca1286,
    0xca1385, 0xcb1385, 0xcb1484, 0xcc1582, 0xcd1681, 0xce1780, 0xce187e, 0xcf187c, 0xcf197b, 0xd01a79, 0xd11b78,
    0xd11c76, 0xd21c75, 0xd21d74, 0xd31e72, 0xd32071, 0xd4216f, 0xd4226e, 0xd5236b, 0xd52469, 0xd62567, 0xd72665,
    0xd82764, 0xd82862, 0xd92a60, 0xda2b5e, 0xda2c5c, 0xdb2e5a, 0xdb2f57, 0xdc2f54, 0xdd3051, 0xdd314e, 0xde324a,
    0xde3347, 0xdf3444, 0xdf3541, 0xdf363d, 0xe0373a, 0xe03837, 0xe03933, 0xe13a30, 0xe23b2d, 0xe23c2a, 0xe33d26,
    0xe33e23, 0xe43f20, 0xe4411d, 0xe4421c, 0xe5431b, 0xe54419, 0xe54518, 0xe64616, 0xe74715, 0xe74814, 0xe74913,
    0xe84a12, 0xe84c10, 0xe84c0f, 0xe94d0e, 0xe94d0d, 0xea4e0c, 0xea4f0c, 0xeb500b, 0xeb510a, 0xeb520a, 0xeb5309,
    0xec5409, 0xec5608, 0xec5708, 0xec5808, 0xed5907, 0xed5a07, 0xed5b06, 0xee5c06, 0xee5c05, 0xee5d05, 0xee5e05,
    0xef5f04, 0xef6004, 0xef6104, 0xef6204, 0xf06303, 0xf06403, 0xf06503, 0xf16603, 0xf16603, 0xf16703, 0xf16803,
    0xf16902, 0xf16a02, 0xf16b02, 0xf16b02, 0xf26c01, 0xf26d01, 0xf26e01, 0xf36f01, 0xf37001, 0xf37101, 0xf37201,
    0xf47300, 0xf47400, 0xf47500, 0xf47600, 0xf47700, 0xf47800, 0xf47a00, 0xf57b00, 0xf57c00, 0xf57e00, 0xf57f00,
    0xf68000, 0xf68100, 0xf68200, 0xf78300, 0xf78400, 0xf78500, 0xf78600, 0xf88700, 0xf88800, 0xf88800, 0xf88900,
    0xf88a00, 0xf88b00, 0xf88c00, 0xf98d00, 0xf98d00, 0xf98e00, 0xf98f00, 0xf99000, 0xf99100, 0xf99200, 0xf99300,
    0xfa9400, 0xfa9500, 0xfa9600, 0xfb9800, 0xfb9900, 0xfb9a00, 0xfb9c00, 0xfc9d00, 0xfc9f00, 0xfca000, 0xfca100,
    0xfda200, 0xfda300, 0xfda400, 0xfda600, 0xfda700, 0xfda800, 0xfdaa00, 0xfdab00, 0xfdac00, 0xfdad00, 0xfdae00,
    0xfeaf00, 0xfeb000, 0xfeb100, 0xfeb200, 0xfeb300, 0xfeb400, 0xfeb500, 0xfeb600, 0xfeb800, 0xfeb900, 0xfeb900,
    0xfeba00, 0xfebb00, 0xfebc00, 0xfebd00, 0xfebe00, 0xfec000, 0xfec100, 0xfec200, 0xfec300, 0xfec400, 0xfec500,
    0xfec600, 0xfec700, 0xfec800, 0xfec901, 0xfeca01, 0xfeca01, 0xfecb01, 0xfecc02, 0xfecd02, 0xfece03, 0xfecf04,
    0xfecf04, 0xfed005, 0xfed106, 0xfed308, 0xfed409, 0xfed50a, 0xfed60a, 0xfed70b, 0xfed80c, 0xfed90d, 0xffda0e,
    0xffda0e, 0xffdb10, 0xffdc12, 0xffdc14, 0xffdd16, 0xffde19, 0xffde1b, 0xffdf1e, 0xffe020, 0xffe122, 0xffe224,
    0xffe226, 0xffe328, 0xffe42b, 0xffe42e, 0xffe531, 0xffe635, 0xffe638, 0xffe73c, 0xffe83f, 0xffe943, 0xffea46,
    0xffeb49, 0xffeb4d, 0xffec50, 0xffed54, 0xffee57, 0xffee5b, 0xffee5f, 0xffef63, 0xffef67, 0xfff06a, 0xfff06e,
    0xfff172, 0xfff177, 0xfff17b, 0xfff280, 0xfff285, 0xfff28a, 0xfff38e, 0xfff492, 0xfff496, 0xfff49a, 0xfff59e,
    0xfff5a2, 0xfff5a6, 0xfff6aa, 0xfff6af, 0xfff7b3, 0xfff7b6, 0xfff8ba, 0xfff8bd, 0xfff8c1, 0xfff8c4, 0xfff9c7,
    0xfff9ca, 0xfff9cd, 0xfffad1, 0xfffad4, 0xfffbd8, 0xfffcdb, 0xfffcdf, 0xfffde2, 0xfffde5, 0xfffde8, 0xfffeeb,
    0xfffeee, 0xfffef1, 0xfffef4, 0xfffff6,
  },

  //RAINBOW
  { 0xFF, 0x2FF, 0x5FF, 0x8FF, 0xBFF, 0xEFF, 0x11FF, 0x14FF, 0x17FF, 0x1AFF, 0x1DFF,
    0x20FF, 0x23FF, 0x26FF, 0x29FF, 0x2CFF, 0x2FFF, 0x32FF, 0x35FF, 0x37FF, 0x3AFF, 0x3DFF,
    0x40FF, 0x43FF, 0x46FF, 0x49FF, 0x4CFF, 0x4FFF, 0x52FF, 0x55FF, 0x58FF, 0x5BFF, 0x5EFF,
    0x61FF, 0x64FF, 0x67FF, 0x6AFF, 0x6CFF, 0x6FFF, 0x72FF, 0x75FF, 0x78FF, 0x7BFF, 0x7EFF,
    0x81FF, 0x84FF, 0x87FF, 0x8AFF, 0x8DFF, 0x90FF, 0x93FF, 0x96FF, 0x99FF, 0x9CFF, 0x9FFF,
    0xA1FF, 0xA4FF, 0xA7FF, 0xAAFF, 0xADFF, 0xB0FF, 0xB3FF, 0xB6FF, 0xB9FF, 0xBCFF, 0xBFFF,
    0xC2FF, 0xC5FF, 0xC8FF, 0xCBFF, 0xCEFF, 0xD1FF, 0xD4FF, 0xD6FF, 0xD9FF, 0xDCFF, 0xDFFF,
    0xE2FF, 0xE5FF, 0xE8FF, 0xEBFF, 0xEEFF, 0xF1FF, 0xF4FF, 0xF7FF, 0xFAFF, 0xFDFF, 0xFFFD,
    0xFFFA, 0xFFF7, 0xFFF4, 0xFFF2, 0xFFEF, 0xFFEC, 0xFFE9, 0xFFE6, 0xFFE3, 0xFFE0, 0xFFDD,
    0xFFDA, 0xFFD7, 0xFFD4, 0xFFD1, 0xFFCE, 0xFFCB, 0xFFC8, 0xFFC5, 0xFFC2, 0xFFBF, 0xFFBD,
    0xFFBA, 0xFFB7, 0xFFB4, 0xFFB1, 0xFFAE, 0xFFAB, 0xFFA8, 0xFFA5, 0xFFA2, 0xFF9F, 0xFF9C,
    0xFF99, 0xFF96, 0xFF93, 0xFF90, 0xFF8D, 0xFF8A, 0xFF88, 0xFF85, 0xFF82, 0xFF7F, 0xFF7C,
    0xFF79, 0xFF76, 0xFF73, 0xFF70, 0xFF6D, 0xFF6A, 0xFF67, 0xFF64, 0xFF61, 0xFF5E, 0xFF5B,
    0xFF58, 0xFF55, 0xFF53, 0xFF50, 0xFF4D, 0xFF4A, 0xFF47, 0xFF44, 0xFF41, 0xFF3E, 0xFF3B,
    0xFF38, 0xFF35, 0xFF32, 0xFF2F, 0xFF2C, 0xFF29, 0xFF26, 0xFF23, 0xFF20, 0xFF1E, 0xFF1B,
    0xFF18, 0xFF15, 0xFF12, 0xFF0F, 0xFF0C, 0xFF09, 0xFF06, 0xFF03, 0xFF00, 0x2FF00, 0x5FF00,
    0x8FF00, 0xBFF00, 0xEFF00, 0x11FF00, 0x14FF00, 0x16FF00, 0x19FF00, 0x1CFF00, 0x1FFF00, 0x22FF00, 0x25FF00,
    0x28FF00, 0x2BFF00, 0x2EFF00, 0x31FF00, 0x34FF00, 0x37FF00, 0x3AFF00, 0x3DFF00, 0x40FF00, 0x43FF00, 0x46FF00,
    0x49FF00, 0x4BFF00, 0x4EFF00, 0x51FF00, 0x54FF00, 0x57FF00, 0x5AFF00, 0x5DFF00, 0x60FF00, 0x63FF00, 0x66FF00,
    0x69FF00, 0x6CFF00, 0x6FFF00, 0x72FF00, 0x75FF00, 0x78FF00, 0x7BFF00, 0x7EFF00, 0x80FF00, 0x83FF00, 0x86FF00,
    0x89FF00, 0x8CFF00, 0x8FFF00, 0x92FF00, 0x95FF00, 0x98FF00, 0x9BFF00, 0x9EFF00, 0xA1FF00, 0xA4FF00, 0xA7FF00,
    0xAAFF00, 0xADFF00, 0xB0FF00, 0xB3FF00, 0xB5FF00, 0xB8FF00, 0xBBFF00, 0xBEFF00, 0xC1FF00, 0xC4FF00, 0xC7FF00,
    0xCAFF00, 0xCDFF00, 0xD0FF00, 0xD3FF00, 0xD6FF00, 0xD9FF00, 0xDCFF00, 0xDFFF00, 0xE2FF00, 0xE5FF00, 0xE8FF00,
    0xEAFF00, 0xEDFF00, 0xF0FF00, 0xF3FF00, 0xF6FF00, 0xF9FF00, 0xFCFF00, 0xFFFE00, 0xFFFB00, 0xFFF800, 0xFFF500,
    0xFFF200, 0xFFEF00, 0xFFEC00, 0xFFE900, 0xFFE600, 0xFFE300, 0xFFE000, 0xFFDE00, 0xFFDB00, 0xFFD800, 0xFFD500,
    0xFFD200, 0xFFCF00, 0xFFCC00, 0xFFC900, 0xFFC600, 0xFFC300, 0xFFC000, 0xFFBD00, 0xFFBA00, 0xFFB700, 0xFFB400,
    0xFFB100, 0xFFAE00, 0xFFAB00, 0xFFA900, 0xFFA600, 0xFFA300, 0xFFA000, 0xFF9D00, 0xFF9A00, 0xFF9700, 0xFF9400,
    0xFF9100, 0xFF8E00, 0xFF8B00, 0xFF8800, 0xFF8500, 0xFF8200, 0xFF7F00, 0xFF7C00, 0xFF7900, 0xFF7600, 0xFF7400,
    0xFF7100, 0xFF6E00, 0xFF6B00, 0xFF6800, 0xFF6500, 0xFF6200, 0xFF5F00, 0xFF5C00, 0xFF5900, 0xFF5600, 0xFF5300,
    0xFF5000, 0xFF4D00, 0xFF4A00, 0xFF4700, 0xFF4400, 0xFF4100, 0xFF3F00, 0xFF3C00, 0xFF3900, 0xFF3600, 0xFF3300,
    0xFF3000, 0xFF2D00, 0xFF2A00, 0xFF2700, 0xFF2400, 0xFF2100, 0xFF1E00, 0xFF1B00, 0xFF1800, 0xFF1500, 0xFF1200,
    0xFF0F00, 0xFF0C00, 0xFF0A00, 0xFF0700, 0xFF0400, 0xFF0100, 0xFF0001, 0xFF0004, 0xFF0007, 0xFF0009, 0xFF000C,
    0xFF000F, 0xFF0012, 0xFF0015, 0xFF0017, 0xFF001A, 0xFF001D, 0xFF0020, 0xFF0022, 0xFF0025, 0xFF0028, 0xFF002B,
    0xFF002E, 0xFF0030, 0xFF0033, 0xFF0036, 0xFF0039, 0xFF003B, 0xFF003E, 0xFF0041, 0xFF0044, 0xFF0046, 0xFF0049,
    0xFF004C, 0xFF004F, 0xFF0052, 0xFF0054, 0xFF0057, 0xFF005A, 0xFF005D, 0xFF005F, 0xFF0062, 0xFF0065, 0xFF0068,
    0xFF006A, 0xFF006D, 0xFF0070, 0xFF0073, 0xFF0076, 0xFF0078, 0xFF007B, 0xFF007E, 0xFF0081, 0xFF0083, 0xFF0086,
    0xFF0089, 0xFF008C, 0xFF008F, 0xFF0091, 0xFF0094, 0xFF0097, 0xFF009A, 0xFF009C, 0xFF009F, 0xFF00A2, 0xFF00A5,
    0xFF00A7, 0xFF00AA, 0xFF00AD, 0xFF00B0, 0xFF00B3, 0xFF00B5, 0xFF00B8, 0xFF00BB, 0xFF00BE, 0xFF00C0, 0xFF00C3,
    0xFF00C6, 0xFF00C9, 0xFF00CB, 0xFF00CE, 0xFF00D1, 0xFF00D4, 0xFF00D7, 0xFF00D9, 0xFF00DC, 0xFF00DF, 0xFF00E2,
    0xFF00E4, 0xFF00E7, 0xFF00EA, 0xFF00ED,
  },

  //RAINBOW HC
  { 0x96, 0x310296, 0x310496, 0x300696, 0x300896, 0x2F0B96, 0x2F0D96, 0x2E0F96, 0x2E1196, 0x2D1396, 0x2D1696,
    0x2C1896, 0x2C1A96, 0x2B1C96, 0x2B1F96, 0x2B2196, 0x2A2396, 0x2A2596, 0x292796, 0x292A96, 0x282C96, 0x282E96,
    0x273096, 0x273296, 0x263596, 0x263796, 0x253996, 0x253B96, 0x253E96, 0x244096, 0x244296, 0x234496, 0x234696,
    0x224996, 0x224B96, 0x214D96, 0x214F96, 0x205296, 0x205496, 0x1F5696, 0x1F5896, 0x1F5A96, 0x1E5D96, 0x1E5F96,
    0x1D6196, 0x1D6396, 0x1C6596, 0x1C6896, 0x1B6A96, 0x1B6C96, 0x1A6E96, 0x1A7196, 0x197396, 0x197596, 0x197796,
    0x187996, 0x187C96, 0x177E96, 0x178096, 0x168296, 0x168596, 0x158796, 0x158996, 0x148B96, 0x148D96, 0x139096,
    0x139296, 0x139496, 0x129696, 0x129896, 0x119B96, 0x119D96, 0x109F96, 0x10A196, 0xFA496, 0xFA696, 0xEA896,
    0xEAA96, 0xDAC96, 0xDAF96, 0xDB196, 0xCB396, 0xCB596, 0xBB896, 0xBBA96, 0xABC96, 0xABE96, 0x9C096,
    0x9C396, 0x8C596, 0x8C796, 0x7C996, 0x7CB96, 0x7CE96, 0x6D096, 0x6D296, 0x5D496, 0x5D796, 0x4D996,
    0x4DB96, 0x3DD96, 0x3DF96, 0x2E296, 0x2E496, 0x1E696, 0x1E896, 0x1EB96, 0xED96, 0xEF96, 0xF094,
    0xF091, 0xF08F, 0xF08D, 0xF08B, 0xF088, 0xF086, 0xF084, 0xF081, 0xF07F, 0xF07D, 0xF07A,
    0xF078, 0xF076, 0xF073, 0xF071, 0xF06F, 0xF06D, 0xF06A, 0xF068, 0xF066, 0xF063, 0xF061,
    0xF05F, 0xF05C, 0xF05A, 0xF058, 0xF055, 0xF053, 0xF051, 0xF04E, 0xF04C, 0xF04A, 0xF048,
    0xF045, 0xF043, 0xF041, 0xF03E, 0xF03C, 0xF03A, 0xF037, 0xF035, 0xF033, 0xF030, 0xF02E,
    0xF02C, 0xF02A, 0xF027, 0xF025, 0xF023, 0xF020, 0xF01E, 0xF01C, 0xF019, 0xF017, 0xF015,
    0xF012, 0xF010, 0xF00E, 0xF00C, 0xF009, 0xF007, 0xF005, 0xF002, 0xF000, 0x3F000, 0x7F000,
    0xAF000, 0xEF000, 0x12F000, 0x16F000, 0x1AF000, 0x1EF000, 0x22F000, 0x26F000, 0x2AF000, 0x2EF000, 0x32F000,
    0x36F000, 0x3AF000, 0x3EF000, 0x41F000, 0x45F000, 0x49F000, 0x4DF000, 0x51F000, 0x55F000, 0x59F000, 0x5DF000,
    0x61F000, 0x65F000, 0x69F000, 0x6DF000, 0x71F000, 0x74F000, 0x78F000, 0x7CF000, 0x80F000, 0x84F000, 0x88F000,
    0x8CF000, 0x90F000, 0x94F000, 0x98F000, 0x9CF000, 0xA0F000, 0xA4F000, 0xA8F000, 0xABF000, 0xAFF000, 0xB3F000,
    0xB7F000, 0xBBF000, 0xBFF000, 0xC3F000, 0xC7F000, 0xCBF000, 0xCFF000, 0xD3F000, 0xD7F000, 0xDBF000, 0xDFF000,
    0xE2F000, 0xE6F000, 0xEAF000, 0xEEF000, 0xF2F000, 0xF6F000, 0xFAF000, 0xFEF000, 0xFFEC00, 0xFFE900, 0xFFE500,
    0xFFE100, 0xFFDE00, 0xFFDA00, 0xFFD600, 0xFFD200, 0xFFCF00, 0xFFCB00, 0xFFC700, 0xFFC400, 0xFFC000, 0xFFBC00,
    0xFFB900, 0xFFB500, 0xFFB100, 0xFFAE00, 0xFFAA00, 0xFFA600, 0xFFA200, 0xFF9F00, 0xFF9B00, 0xFF9700, 0xFF9400,
    0xFF9000, 0xFF8C00, 0xFF8900, 0xFF8500, 0xFF8100, 0xFF7E00, 0xFF7A00, 0xFF7600, 0xFF7200, 0xFF6F00, 0xFF6B00,
    0xFF6700, 0xFF6400, 0xFF6000, 0xFF5C00, 0xFF5900, 0xFF5500, 0xFF5100, 0xFF4D00, 0xFF4A00, 0xFF4600, 0xFF4200,
    0xFF3F00, 0xFF3B00, 0xFF3700, 0xFF3400, 0xFF3000, 0xFF2C00, 0xFF2900, 0xFF2500, 0xFF2100, 0xFF1D00, 0xFF1A00,
    0xFF1600, 0xFF1200, 0xFF0F00, 0xFF0B00, 0xFF0700, 0xFF0400, 0xFF0000, 0xFF0101, 0xFF0303, 0xFF0504, 0xFF0706,
    0xFF0908, 0xFF0B09, 0xFF0D0B, 0xFF0F0D, 0xFF110F, 0xFF1310, 0xFF1412, 0xFF1614, 0xFF1815, 0xFF1A17, 0xFF1C19,
    0xFF1E1A, 0xFF201C, 0xFF221E, 0xFF2420, 0xFF2621, 0xFF2823, 0xFF2A25, 0xFF2C26, 0xFF2D28, 0xFF2F2A, 0xFF312B,
    0xFF332D, 0xFF352F, 0xFF3730, 0xFF3932, 0xFF3B34, 0xFF3D36, 0xFF3F37, 0xFF4139, 0xFF433B, 0xFF453C, 0xFF473E,
    0xFF4840, 0xFF4A41, 0xFF4C43, 0xFF4E45, 0xFF5046, 0xFF5248, 0xFF544A, 0xFF564C, 0xFF584D, 0xFF5A4F, 0xFF5C51,
    0xFF5E52, 0xFF6054, 0xFF6156, 0xFF6357, 0xFF6559, 0xFF675B, 0xFF695C, 0xFF6B5E, 0xFF6D60, 0xFF6F62, 0xFF7163,
    0xFF7365, 0xFF7567, 0xFF7768, 0xFF796A, 0xFF7A6C, 0xFF7C6D, 0xFF7E6F, 0xFF8071, 0xFF8272, 0xFF8474, 0xFF8676,
    0xFF8878, 0xFF8A79, 0xFF8C7B, 0xFF8E7D, 0xFF907E, 0xFF9280, 0xFF9382, 0xFF9583, 0xFF9785, 0xFF9987, 0xFF9B89,
    0xFF9D8A, 0xFF9F8C, 0xFFA18E, 0xFFA38F, 0xFFA591, 0xFFA793, 0xFFA994, 0xFFAB96, 0xFFAD98, 0xFFAE99, 0xFFB09B,
    0xFFB29D, 0xFFB49F, 0xFFB6A0, 0xFFB8A2, 0xFFBAA4, 0xFFBCA5, 0xFFBEA7, 0xFFC0A9, 0xFFC2AA, 0xFFC4AC, 0xFFC6AE,
    0xFFC7AF, 0xFFC9B1, 0xFFCBB3, 0xFFCDB5, 0xFFCFB6, 0xFFD1B8, 0xFFD3BA, 0xFFD5BB, 0xFFD7BD, 0xFFD9BF, 0xFFDBC0,
    0xFFDDC2, 0xFFDFC4, 0xFFE0C5, 0xFFE2C7, 0xFFE4C9, 0xFFE6CB, 0xFFE8CC, 0xFFEACE, 0xFFECD0, 0xFFEED1, 0xFFF0D3,
    0xFFF2D5, 0xFFF4D6, 0xFFF6D8, 0xFFF8DA,
  },

  // ARCTIC
  { 0x3C96, 0x3E97, 0x13F98, 0x24198, 0x34399, 0x4449A, 0x5469B, 0x6479C, 0x7499D, 0x84B9D, 0x94C9E,
    0xA4E9F, 0xB50A0, 0xC51A1, 0xD53A1, 0xE54A2, 0xF56A3, 0x1058A4, 0x1159A5, 0x125BA5, 0x135DA6, 0x145EA7,
    0x1560A8, 0x1661A9, 0x1763AA, 0x1865AA, 0x1966AB, 0x1968AC, 0x1A6AAD, 0x1B6BAE, 0x1C6DAE, 0x1D6EAF, 0x1E70B0,
    0x1F72B1, 0x2073B2, 0x2175B2, 0x2277B3, 0x2378B4, 0x247AB5, 0x257BB6, 0x267DB7, 0x277FB7, 0x2880B8, 0x2982B9,
    0x2A84BA, 0x2B85BB, 0x2C87BB, 0x2D89BC, 0x2E8ABD, 0x2F8CBE, 0x308DBF, 0x318FC0, 0x3291C0, 0x3392C1, 0x3394C2,
    0x3496C3, 0x3597C4, 0x3699C4, 0x379AC5, 0x389CC6, 0x399EC7, 0x3A9FC8, 0x3BA1C8, 0x3CA3C9, 0x3DA4CA, 0x3EA6CB,
    0x3FA7CC, 0x40A9CD, 0x41ABCD, 0x42ACCE, 0x43AECF, 0x44B0D0, 0x45B1D1, 0x46B3D1, 0x47B4D2, 0x48B6D3, 0x49B8D4,
    0x4AB9D5, 0x4BBBD5, 0x4CBDD6, 0x4CBED7, 0x4DC0D8, 0x4EC1D9, 0x4FC3DA, 0x50C5DA, 0x51C6DB, 0x52C8DC, 0x53C8DC,
    0x54C7DA, 0x55C7D9, 0x56C6D8, 0x57C5D6, 0x58C4D5, 0x59C4D4, 0x5AC3D3, 0x5BC2D1, 0x5CC1D0, 0x5DC1CF, 0x5EC0CD,
    0x5FBFCC, 0x60BECB, 0x61BDC9, 0x62BDC8, 0x63BCC7, 0x64BBC5, 0x65BAC4, 0x66BAC3, 0x66B9C2, 0x67B8C0, 0x68B7BF,
    0x69B7BE, 0x6AB6BC, 0x6BB5BB, 0x6CB4BA, 0x6DB3B8, 0x6EB3B7, 0x6FB2B6, 0x70B1B4, 0x71B0B3, 0x72B0B2, 0x73AFB1,
    0x74AEAF, 0x75ADAE, 0x76ADAD, 0x77ACAB, 0x78ABAA, 0x79AAA9, 0x7AA9A7, 0x7BA9A6, 0x7CA8A5, 0x7DA7A3, 0x7EA6A2,
    0x7FA6A1, 0x7FA5A0, 0x80A49E, 0x81A39D, 0x82A39C, 0x83A29A, 0x84A199, 0x85A098, 0x869F96, 0x879F95, 0x889E94,
    0x899D92, 0x8A9C91, 0x8B9C90, 0x8C9B8F, 0x8D9A8D, 0x8E998C, 0x8F998B, 0x909889, 0x919788, 0x929687, 0x939585,
    0x949584, 0x959483, 0x969381, 0x979280, 0x98927F, 0x99917E, 0x99907C, 0x9A8F7B, 0x9B8F7A, 0x9C8E78, 0x9D8D77,
    0x9E8C76, 0x9F8B74, 0xA08B73, 0xA18A72, 0xA28970, 0xA3886F, 0xA4886E, 0xA5876D, 0xA6866B, 0xA7856A, 0xA88569,
    0xA98467, 0xAA8366, 0xAB8265, 0xAC8163, 0xAD8162, 0xAE8061, 0xAF7F5F, 0xB07E5E, 0xB17E5D, 0xB27D5C, 0xB27C5A,
    0xB37B59, 0xB47B58, 0xB57A56, 0xB67955, 0xB77854, 0xB87752, 0xB97751, 0xBA7650, 0xBB754E, 0xBC744D, 0xBD744C,
    0xBE734B, 0xBF7249, 0xC07148, 0xC17147, 0xC27045, 0xC36F44, 0xC46E43, 0xC56D41, 0xC66D40, 0xC76C3F, 0xC86B3D,
    0xC96A3C, 0xCA6A3B, 0xCB693A, 0xCC6838, 0xCC6737, 0xCD6736, 0xCE6634, 0xCF6533, 0xD06432, 0xD16432, 0xD26432,
    0xD36432, 0xD46432, 0xD56432, 0xD66432, 0xD76432, 0xD86432, 0xD96432, 0xDA6432, 0xDB6432, 0xDC6432, 0xDD6432,
    0xDE6432, 0xDF6432, 0xE06432, 0xE16432, 0xE26432, 0xE36432, 0xE46432, 0xE56432, 0xE56432, 0xE66432, 0xE76432,
    0xE86432, 0xE96432, 0xEA6432, 0xEB6432, 0xEC6432, 0xED6432, 0xEE6432, 0xEF6432, 0xF06432, 0xF16432, 0xF26432,
    0xF36432, 0xF46432, 0xF56432, 0xF66432, 0xF76432, 0xF86432, 0xF96432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432,
    0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432,
    0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432,
    0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432,
    0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432,
    0xFA6432, 0xFA6432, 0xFA6432, 0xFA6432, 0xFA6433, 0xFA6434, 0xFA6435, 0xFA6436, 0xFA6437, 0xFA6438, 0xFA6439,
    0xFA643A, 0xFA643B, 0xFA643C, 0xFA643D, 0xFA663E, 0xFA673F, 0xFA693F, 0xFA6B40, 0xFA6C41, 0xFA6E42, 0xFA6F43,
    0xFA7144, 0xFA7345, 0xFA7446, 0xFA7647, 0xFA7748, 0xFA7949, 0xFA7B4A, 0xFA7C4B, 0xFA7E4C, 0xFA804D, 0xFA814E,
    0xFA834F, 0xFA8450, 0xFA8651, 0xFA8852, 0xFA8953, 0xFA8B54, 0xFA8C55, 0xFA8E56, 0xFA9057, 0xFA9158, 0xFA9359,
    0xFA955A, 0xFA965B, 0xFA985C, 0xFA995D, 0xFA9B5E, 0xFA9D5F, 0xFA9E60, 0xFAA061, 0xFAA162, 0xFAA363, 0xFAA564,
    0xFAA665, 0xFAA866, 0xFAAA67, 0xFAAB68, 0xFAAD69, 0xFAAE6A, 0xFAB06B, 0xFAB26C, 0xFAB36D, 0xFAB56E, 0xFAB76F,
    0xFAB870, 0xFABA71, 0xFABB72, 0xFABD73, 0xFABF74, 0xFAC074, 0xFAC275, 0xFAC376, 0xFAC577, 0xFAC778, 0xFAC879,
    0xFACA7A, 0xFACC7B, 0xFACD7C, 0xFACF7D, 0xFAD07E, 0xFAD27F, 0xFAD480, 0xFAD581, 0xFAD782, 0xFAD883, 0xFADA84,
    0xFADC85, 0xFADD86, 0xFADF87, 0xFAE188, 0xFAE289, 0xFAE48A, 0xFAE58B, 0xFAE78C, 0xFAE98D, 0xFAEA8E, 0xFAEC8F,
    0xFAED90, 0xFAEF91, 0xFAF092, 0xFAF093, 0xFAF094, 0xFAF095, 0xFAF096, 0xFAF097, 0xFAF098, 0xFAF099, 0xFAF09A,
    0xFAF09B, 0xFAF09C, 0xFAF09D, 0xFAF09E, 0xFAF09F, 0xFAF0A0, 0xFAF0A1, 0xFAF0A2, 0xFAF0A3, 0xFAF0A4, 0xFAF0A5,
    0xFAF0A6, 0xFAF0A7, 0xFAF0A8, 0xFAF0A9,
  },

  //OUTDOOR_ALERT
  { 0xF5F5F5, 0xF4F4F4, 0xF3F3F3, 0xF2F2F2, 0xF1F1F1, 0xF1F1F1, 0xF0F0F0, 0xEFEFEF, 0xEEEEEE, 0xEEEEEE, 0xEDEDED,
    0xECECEC, 0xEBEBEB, 0xEBEBEB, 0xEAEAEA, 0xE9E9E9, 0xE8E8E8, 0xE8E8E8, 0xE7E7E7, 0xE6E6E6, 0xE5E5E5, 0xE5E5E5,
    0xE4E4E4, 0xE3E3E3, 0xE2E2E2, 0xE2E2E2, 0xE1E1E1, 0xE0E0E0, 0xDFDFDF, 0xDFDFDF, 0xDEDEDE, 0xDDDDDD, 0xDCDCDC,
    0xDCDCDC, 0xDBDBDB, 0xDADADA, 0xD9D9D9, 0xD9D9D9, 0xD8D8D8, 0xD7D7D7, 0xD6D6D6, 0xD6D6D6, 0xD5D5D5, 0xD4D4D4,
    0xD3D3D3, 0xD3D3D3, 0xD2D2D2, 0xD1D1D1, 0xD0D0D0, 0xD0D0D0, 0xCFCFCF, 0xCECECE, 0xCDCDCD, 0xCDCDCD, 0xCCCCCC,
    0xCBCBCB, 0xCACACA, 0xC9C9C9, 0xC9C9C9, 0xC8C8C8, 0xC7C7C7, 0xC6C6C6, 0xC6C6C6, 0xC5C5C5, 0xC4C4C4, 0xC3C3C3,
    0xC3C3C3, 0xC2C2C2, 0xC1C1C1, 0xC0C0C0, 0xC0C0C0, 0xBFBFBF, 0xBEBEBE, 0xBDBDBD, 0xBDBDBD, 0xBCBCBC, 0xBBBBBB,
    0xBABABA, 0xBABABA, 0xB9B9B9, 0xB8B8B8, 0xB7B7B7, 0xB7B7B7, 0xB6B6B6, 0xB5B5B5, 0xB4B4B4, 0xB4B4B4, 0xB3B3B3,
    0xB2B2B2, 0xB1B1B1, 0xB1B1B1, 0xB0B0B0, 0xAFAFAF, 0xAEAEAE, 0xAEAEAE, 0xADADAD, 0xACACAC, 0xABABAB, 0xABABAB,
    0xAAAAAA, 0xA9A9A9, 0xA8A8A8, 0xA8A8A8, 0xA7A7A7, 0xA6A6A6, 0xA5A5A5, 0xA5A5A5, 0xA4A4A4, 0xA3A3A3, 0xA2A2A2,
    0xA2A2A2, 0xA1A1A1, 0xA0A0A0, 0x9F9F9F, 0x9E9E9E, 0x9E9E9E, 0x9D9D9D, 0x9C9C9C, 0x9B9B9B, 0x9B9B9B, 0x9A9A9A,
    0x999999, 0x989898, 0x989898, 0x979797, 0x969696, 0x959595, 0x959595, 0x949494, 0x939393, 0x929292, 0x929292,
    0x919191, 0x909090, 0x8F8F8F, 0x8F8F8F, 0x8E8E8E, 0x8D8D8D, 0x8C8C8C, 0x8C8C8C, 0x8B8B8B, 0x8A8A8A, 0x898989,
    0x898989, 0x888888, 0x878787, 0x868686, 0x868686, 0x858585, 0x848484, 0x838383, 0x838383, 0x828282, 0x818181,
    0x808080, 0x808080, 0x7F7F7F, 0x7E7E7E, 0x7D7D7D, 0x7D7D7D, 0x7C7C7C, 0x7B7B7B, 0x7A7A7A, 0x7A7A7A, 0x797979,
    0x787878, 0x777777, 0x777777, 0x767676, 0x757575, 0x747474, 0x737373, 0x737373, 0x727272, 0x717171, 0x707070,
    0x707070, 0x6F6F6F, 0x6E6E6E, 0x6D6D6D, 0x6D6D6D, 0x6C6C6C, 0x6B6B6B, 0x6A6A6A, 0x6A6A6A, 0x696969, 0x686868,
    0x676767, 0x676767, 0x666666, 0x656565, 0x646464, 0x646464, 0x636363, 0x626262, 0x616161, 0x616161, 0x606060,
    0x5F5F5F, 0x5E5E5E, 0x5E5E5E, 0x5D5D5D, 0x5C5C5C, 0x5B5B5B, 0x5B5B5B, 0x5A5A5A, 0x595959, 0x585858, 0x585858,
    0x575757, 0x565656, 0x555555, 0x555555, 0x545454, 0x535353, 0x525252, 0x525252, 0x515151, 0x505050, 0x4F4F4F,
    0x4F4F4F, 0x4E4E4E, 0x4D4D4D, 0x4C4C4C, 0x4C4C4C, 0x4B4B4B, 0x4A4A4A, 0x494949, 0x484848, 0x484848, 0x474747,
    0x464646, 0x454545, 0x454545, 0x444444, 0x434343, 0x424242, 0x424242, 0x414141, 0x404040, 0x3F3F3F, 0x3F3F3F,
    0x3E3E3E, 0x3D3D3D, 0x3C3C3C, 0x3C3C3C, 0x3B3B3B, 0x3A3A3A, 0x393939, 0x393939, 0x383838, 0x373737, 0x363636,
    0x363636, 0x353535, 0x343434, 0x333333, 0x333333, 0x323232, 0x313131, 0x303030, 0x303030, 0x2F2F2F, 0x2E2E2E,
    0x2D2D2D, 0x2D2D2D, 0x2C2C2C, 0x2B2B2B, 0x2A2A2A, 0x2A2A2A, 0x292929, 0x282828, 0x272727, 0x272727, 0x262626,
    0x252525, 0x242424, 0x242424, 0x232323, 0x222222, 0x212121, 0x212121, 0x202020, 0x1F1F1F, 0x1E1E1E, 0x1D1D1D,
    0x1D1D1D, 0x1C1C1C, 0x1B1B1B, 0x1A1A1A, 0x1A1A1A, 0x191919, 0x181818, 0x171717, 0x171717, 0x161616, 0x151515,
    0x141414, 0x141414, 0x131313, 0x121212, 0x111111, 0x111111, 0x101010, 0xF0F0F,  0xE0E0E,  0xE0E0E,  0xD0D0D,
    0xC0C0C, 0xB0B0B,  0xB0B0B,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,
    0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0x3C0A0A, 0x410A0A, 0x460A0A,
    0x4B0A0A, 0x500B0B, 0x550B0B, 0x5A0C0C, 0x5F0D0D, 0x640E0E, 0x690E0E, 0x6E0F0F, 0x731010, 0x781010, 0x7D1111,
    0x821212, 0x871212, 0x8C1313, 0x911414, 0x961414, 0x9B1515, 0xA01616, 0xA51717, 0xAA1717, 0xAF1818, 0xB31919,
    0xB81919, 0xBD1A1A, 0xC21B1B, 0xC71B1B, 0xCC1C1C, 0xD11D1D, 0xD61D1D, 0xE12805, 0xE12805, 0xE12805, 0xE12805,
    0xE12805, 0xE23835, 0xE53B30, 0xE83E2A, 0xEB4125, 0xEE4420, 0xF0461A, 0xF34915, 0xF64C10, 0xF94F0A, 0xFC5205,
    0xFF5500, 0xFF5700, 0xFF5A00, 0xFF5D00, 0xFF6000, 0xFF6300, 0xFF6600, 0xFF6800, 0xFF6B00, 0xFF6E00, 0xFF7100,
    0xFF7400, 0xFF7700, 0xFF7900, 0xFF7C00, 0xFF7F00, 0xFF8200, 0xFF8500, 0xFF8800, 0xFF8A00, 0xFF8D00, 0xFF9000,
    0xFF9300, 0xFF9600, 0xFF9900, 0xFF9B00, 0xFF9E00, 0xFFA100, 0xFFA400, 0xFFA700, 0xFFAA00, 0xFFAC07, 0xFFAF0F,
    0xFFB216, 0xFFB51E, 0xFFB825, 0xFFBB2D, 0xFFBD34, 0xFFC03C, 0xFFC343, 0xFFC64B, 0xFFC952, 0xFFCC5A, 0xFFCE61,
    0xFFD169, 0xFFD470, 0xFFD778, 0xFFDA7F, 0xFFDD87, 0xFFDF8E, 0xFFE296, 0xFFE59D, 0xFFE8A5, 0xFFEBAC, 0xFFEEB4,
    0xFFF0BB, 0xFFF3C3, 0xFFF6CA, 0xFFF9D2,
  },

  //WHITE_HOT
  { 0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,
    0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xB0B0B,
    0xB0B0B,  0xC0C0C,  0xD0D0D,  0xD0D0D,  0xE0E0E,  0xE0E0E,  0xF0F0F,  0xF0F0F,  0x101010, 0x101010, 0x111111,
    0x111111, 0x121212, 0x121212, 0x131313, 0x141414, 0x141414, 0x151515, 0x151515, 0x161616, 0x161616, 0x171717,
    0x171717, 0x181818, 0x181818, 0x191919, 0x1A1A1A, 0x1A1A1A, 0x1B1B1B, 0x1B1B1B, 0x1C1C1C, 0x1C1C1C, 0x1D1D1D,
    0x1D1D1D, 0x1E1E1E, 0x1E1E1E, 0x1F1F1F, 0x202020, 0x202020, 0x212121, 0x212121, 0x222222, 0x222222, 0x232323,
    0x232323, 0x242424, 0x242424, 0x252525, 0x252525, 0x262626, 0x272727, 0x272727, 0x282828, 0x282828, 0x292929,
    0x292929, 0x2A2A2A, 0x2A2A2A, 0x2B2B2B, 0x2B2B2B, 0x2C2C2C, 0x2D2D2D, 0x2D2D2D, 0x2E2E2E, 0x2E2E2E, 0x2F2F2F,
    0x2F2F2F, 0x303030, 0x303030, 0x313131, 0x313131, 0x323232, 0x333333, 0x333333, 0x343434, 0x343434, 0x353535,
    0x353535, 0x363636, 0x363636, 0x373737, 0x373737, 0x383838, 0x383838, 0x393939, 0x3A3A3A, 0x3A3A3A, 0x3B3B3B,
    0x3B3B3B, 0x3C3C3C, 0x3C3C3C, 0x3D3D3D, 0x3D3D3D, 0x3E3E3E, 0x3E3E3E, 0x3F3F3F, 0x404040, 0x404040, 0x414141,
    0x414141, 0x424242, 0x424242, 0x434343, 0x434343, 0x444444, 0x444444, 0x454545, 0x464646, 0x464646, 0x474747,
    0x474747, 0x484848, 0x484848, 0x494949, 0x494949, 0x4A4A4A, 0x4A4A4A, 0x4B4B4B, 0x4B4B4B, 0x4C4C4C, 0x4D4D4D,
    0x4D4D4D, 0x4E4E4E, 0x4E4E4E, 0x4F4F4F, 0x4F4F4F, 0x505050, 0x505050, 0x515151, 0x515151, 0x525252, 0x535353,
    0x535353, 0x545454, 0x545454, 0x555555, 0x555555, 0x565656, 0x565656, 0x575757, 0x575757, 0x585858, 0x595959,
    0x595959, 0x5A5A5A, 0x5A5A5A, 0x5B5B5B, 0x5B5B5B, 0x5C5C5C, 0x5C5C5C, 0x5D5D5D, 0x5D5D5D, 0x5E5E5E, 0x5E5E5E,
    0x5F5F5F, 0x606060, 0x606060, 0x616161, 0x616161, 0x626262, 0x626262, 0x636363, 0x636363, 0x646464, 0x646464,
    0x656565, 0x666666, 0x666666, 0x676767, 0x676767, 0x686868, 0x686868, 0x696969, 0x696969, 0x6A6A6A, 0x6A6A6A,
    0x6B6B6B, 0x6C6C6C, 0x6C6C6C, 0x6D6D6D, 0x6D6D6D, 0x6E6E6E, 0x6E6E6E, 0x6F6F6F, 0x6F6F6F, 0x707070, 0x707070,
    0x717171, 0x717171, 0x727272, 0x737373, 0x737373, 0x747474, 0x747474, 0x757575, 0x757575, 0x767676, 0x767676,
    0x777777, 0x777777, 0x787878, 0x797979, 0x797979, 0x7A7A7A, 0x7A7A7A, 0x7B7B7B, 0x7B7B7B, 0x7C7C7C, 0x7C7C7C,
    0x7D7D7D, 0x7D7D7D, 0x7E7E7E, 0x7E7E7E, 0x7F7F7F, 0x808080, 0x808080, 0x818181, 0x818181, 0x828282, 0x828282,
    0x838383, 0x838383, 0x848484, 0x848484, 0x858585, 0x868686, 0x868686, 0x878787, 0x878787, 0x888888, 0x888888,
    0x898989, 0x898989, 0x8A8A8A, 0x8A8A8A, 0x8B8B8B, 0x8C8C8C, 0x8C8C8C, 0x8D8D8D, 0x8D8D8D, 0x8E8E8E, 0x8E8E8E,
    0x8F8F8F, 0x8F8F8F, 0x909090, 0x909090, 0x919191, 0x919191, 0x929292, 0x939393, 0x939393, 0x949494, 0x949494,
    0x959595, 0x959595, 0x969696, 0x969696, 0x979797, 0x979797, 0x989898, 0x999999, 0x999999, 0x9A9A9A, 0x9A9A9A,
    0x9B9B9B, 0x9B9B9B, 0x9C9C9C, 0x9C9C9C, 0x9D9D9D, 0x9D9D9D, 0x9E9E9E, 0x9F9F9F, 0x9F9F9F, 0xA0A0A0, 0xA0A0A0,
    0xA1A1A1, 0xA1A1A1, 0xA2A2A2, 0xA2A2A2, 0xA3A3A3, 0xA3A3A3, 0xA4A4A4, 0xA4A4A4, 0xA5A5A5, 0xA6A6A6, 0xA6A6A6,
    0xA7A7A7, 0xA7A7A7, 0xA8A8A8, 0xA8A8A8, 0xA9A9A9, 0xA9A9A9, 0xAAAAAA, 0xAAAAAA, 0xABABAB, 0xACACAC, 0xACACAC,
    0xADADAD, 0xADADAD, 0xAEAEAE, 0xAEAEAE, 0xAFAFAF, 0xAFAFAF, 0xB0B0B0, 0xB0B0B0, 0xB1B1B1, 0xB2B2B2, 0xB2B2B2,
    0xB3B3B3, 0xB3B3B3, 0xB4B4B4, 0xB4B4B4, 0xB5B5B5, 0xB5B5B5, 0xB6B6B6, 0xB6B6B6, 0xB7B7B7, 0xB7B7B7, 0xB8B8B8,
    0xB9B9B9, 0xB9B9B9, 0xBABABA, 0xBABABA, 0xBBBBBB, 0xBBBBBB, 0xBCBCBC, 0xBCBCBC, 0xBDBDBD, 0xBDBDBD, 0xBEBEBE,
    0xBFBFBF, 0xBFBFBF, 0xC0C0C0, 0xC0C0C0, 0xC1C1C1, 0xC1C1C1, 0xC2C2C2, 0xC2C2C2, 0xC3C3C3, 0xC3C3C3, 0xC4C4C4,
    0xC5C5C5, 0xC5C5C5, 0xC6C6C6, 0xC6C6C6, 0xC7C7C7, 0xC7C7C7, 0xC8C8C8, 0xC8C8C8, 0xC9C9C9, 0xC9C9C9, 0xCACACA,
    0xCACACA, 0xCBCBCB, 0xCCCCCC, 0xCCCCCC, 0xCDCDCD, 0xCDCDCD, 0xCECECE, 0xCECECE, 0xCFCFCF, 0xCFCFCF, 0xD0D0D0,
    0xD0D0D0, 0xD1D1D1, 0xD2D2D2, 0xD2D2D2, 0xD3D3D3, 0xD3D3D3, 0xD4D4D4, 0xD4D4D4, 0xD5D5D5, 0xD5D5D5, 0xD6D6D6,
    0xD6D6D6, 0xD7D7D7, 0xD8D8D8, 0xD8D8D8, 0xD9D9D9, 0xD9D9D9, 0xDADADA, 0xDADADA, 0xDBDBDB, 0xDBDBDB, 0xDCDCDC,
    0xDCDCDC, 0xDDDDDD, 0xDDDDDD, 0xDEDEDE, 0xDFDFDF, 0xDFDFDF, 0xE0E0E0, 0xE0E0E0, 0xE1E1E1, 0xE1E1E1, 0xE2E2E2,
    0xE2E2E2, 0xE3E3E3, 0xE3E3E3, 0xE4E4E4, 0xE5E5E5, 0xE5E5E5, 0xE6E6E6, 0xE6E6E6, 0xE7E7E7, 0xE7E7E7, 0xE8E8E8,
    0xE8E8E8, 0xE9E9E9, 0xE9E9E9, 0xEAEAEA,
  },

  //BLACK_HOT
  { 0xEBEBEB, 0xEAEAEA, 0xE9E9E9, 0xE9E9E9, 0xE8E8E8, 0xE8E8E8, 0xE7E7E7, 0xE7E7E7, 0xE6E6E6, 0xE6E6E6, 0xE5E5E5,
    0xE5E5E5, 0xE4E4E4, 0xE3E3E3, 0xE3E3E3, 0xE2E2E2, 0xE2E2E2, 0xE1E1E1, 0xE1E1E1, 0xE0E0E0, 0xE0E0E0, 0xDFDFDF,
    0xDFDFDF, 0xDEDEDE, 0xDDDDDD, 0xDDDDDD, 0xDCDCDC, 0xDCDCDC, 0xDBDBDB, 0xDBDBDB, 0xDADADA, 0xDADADA, 0xD9D9D9,
    0xD9D9D9, 0xD8D8D8, 0xD8D8D8, 0xD7D7D7, 0xD6D6D6, 0xD6D6D6, 0xD5D5D5, 0xD5D5D5, 0xD4D4D4, 0xD4D4D4, 0xD3D3D3,
    0xD3D3D3, 0xD2D2D2, 0xD2D2D2, 0xD1D1D1, 0xD0D0D0, 0xD0D0D0, 0xCFCFCF, 0xCFCFCF, 0xCECECE, 0xCECECE, 0xCDCDCD,
    0xCDCDCD, 0xCCCCCC, 0xCCCCCC, 0xCBCBCB, 0xCACACA, 0xCACACA, 0xC9C9C9, 0xC9C9C9, 0xC8C8C8, 0xC8C8C8, 0xC7C7C7,
    0xC7C7C7, 0xC6C6C6, 0xC6C6C6, 0xC5C5C5, 0xC5C5C5, 0xC4C4C4, 0xC3C3C3, 0xC3C3C3, 0xC2C2C2, 0xC2C2C2, 0xC1C1C1,
    0xC1C1C1, 0xC0C0C0, 0xC0C0C0, 0xBFBFBF, 0xBFBFBF, 0xBEBEBE, 0xBDBDBD, 0xBDBDBD, 0xBCBCBC, 0xBCBCBC, 0xBBBBBB,
    0xBBBBBB, 0xBABABA, 0xBABABA, 0xB9B9B9, 0xB9B9B9, 0xB8B8B8, 0xB7B7B7, 0xB7B7B7, 0xB6B6B6, 0xB6B6B6, 0xB5B5B5,
    0xB5B5B5, 0xB4B4B4, 0xB4B4B4, 0xB3B3B3, 0xB3B3B3, 0xB2B2B2, 0xB2B2B2, 0xB1B1B1, 0xB0B0B0, 0xB0B0B0, 0xAFAFAF,
    0xAFAFAF, 0xAEAEAE, 0xAEAEAE, 0xADADAD, 0xADADAD, 0xACACAC, 0xACACAC, 0xABABAB, 0xAAAAAA, 0xAAAAAA, 0xA9A9A9,
    0xA9A9A9, 0xA8A8A8, 0xA8A8A8, 0xA7A7A7, 0xA7A7A7, 0xA6A6A6, 0xA6A6A6, 0xA5A5A5, 0xA4A4A4, 0xA4A4A4, 0xA3A3A3,
    0xA3A3A3, 0xA2A2A2, 0xA2A2A2, 0xA1A1A1, 0xA1A1A1, 0xA0A0A0, 0xA0A0A0, 0x9F9F9F, 0x9F9F9F, 0x9E9E9E, 0x9D9D9D,
    0x9D9D9D, 0x9C9C9C, 0x9C9C9C, 0x9B9B9B, 0x9B9B9B, 0x9A9A9A, 0x9A9A9A, 0x999999, 0x999999, 0x989898, 0x979797,
    0x979797, 0x969696, 0x969696, 0x959595, 0x959595, 0x949494, 0x949494, 0x939393, 0x939393, 0x929292, 0x919191,
    0x919191, 0x909090, 0x909090, 0x8F8F8F, 0x8F8F8F, 0x8E8E8E, 0x8E8E8E, 0x8D8D8D, 0x8D8D8D, 0x8C8C8C, 0x8C8C8C,
    0x8B8B8B, 0x8A8A8A, 0x8A8A8A, 0x898989, 0x898989, 0x888888, 0x888888, 0x878787, 0x878787, 0x868686, 0x868686,
    0x858585, 0x848484, 0x848484, 0x838383, 0x838383, 0x828282, 0x828282, 0x818181, 0x818181, 0x808080, 0x808080,
    0x7F7F7F, 0x7E7E7E, 0x7E7E7E, 0x7D7D7D, 0x7D7D7D, 0x7C7C7C, 0x7C7C7C, 0x7B7B7B, 0x7B7B7B, 0x7A7A7A, 0x7A7A7A,
    0x797979, 0x797979, 0x787878, 0x777777, 0x777777, 0x767676, 0x767676, 0x757575, 0x757575, 0x747474, 0x747474,
    0x737373, 0x737373, 0x727272, 0x717171, 0x717171, 0x707070, 0x707070, 0x6F6F6F, 0x6F6F6F, 0x6E6E6E, 0x6E6E6E,
    0x6D6D6D, 0x6D6D6D, 0x6C6C6C, 0x6C6C6C, 0x6B6B6B, 0x6A6A6A, 0x6A6A6A, 0x696969, 0x696969, 0x686868, 0x686868,
    0x676767, 0x676767, 0x666666, 0x666666, 0x656565, 0x646464, 0x646464, 0x636363, 0x636363, 0x626262, 0x626262,
    0x616161, 0x616161, 0x606060, 0x606060, 0x5F5F5F, 0x5E5E5E, 0x5E5E5E, 0x5D5D5D, 0x5D5D5D, 0x5C5C5C, 0x5C5C5C,
    0x5B5B5B, 0x5B5B5B, 0x5A5A5A, 0x5A5A5A, 0x595959, 0x595959, 0x585858, 0x575757, 0x575757, 0x565656, 0x565656,
    0x555555, 0x555555, 0x545454, 0x545454, 0x535353, 0x535353, 0x525252, 0x515151, 0x515151, 0x505050, 0x505050,
    0x4F4F4F, 0x4F4F4F, 0x4E4E4E, 0x4E4E4E, 0x4D4D4D, 0x4D4D4D, 0x4C4C4C, 0x4B4B4B, 0x4B4B4B, 0x4A4A4A, 0x4A4A4A,
    0x494949, 0x494949, 0x484848, 0x484848, 0x474747, 0x474747, 0x464646, 0x464646, 0x454545, 0x444444, 0x444444,
    0x434343, 0x434343, 0x424242, 0x424242, 0x414141, 0x414141, 0x404040, 0x404040, 0x3F3F3F, 0x3E3E3E, 0x3E3E3E,
    0x3D3D3D, 0x3D3D3D, 0x3C3C3C, 0x3C3C3C, 0x3B3B3B, 0x3B3B3B, 0x3A3A3A, 0x3A3A3A, 0x393939, 0x383838, 0x383838,
    0x373737, 0x373737, 0x363636, 0x363636, 0x353535, 0x353535, 0x343434, 0x343434, 0x333333, 0x333333, 0x323232,
    0x313131, 0x313131, 0x303030, 0x303030, 0x2F2F2F, 0x2F2F2F, 0x2E2E2E, 0x2E2E2E, 0x2D2D2D, 0x2D2D2D, 0x2C2C2C,
    0x2B2B2B, 0x2B2B2B, 0x2A2A2A, 0x2A2A2A, 0x292929, 0x292929, 0x282828, 0x282828, 0x272727, 0x272727, 0x262626,
    0x252525, 0x252525, 0x242424, 0x242424, 0x232323, 0x232323, 0x222222, 0x222222, 0x212121, 0x212121, 0x202020,
    0x202020, 0x1F1F1F, 0x1E1E1E, 0x1E1E1E, 0x1D1D1D, 0x1D1D1D, 0x1C1C1C, 0x1C1C1C, 0x1B1B1B, 0x1B1B1B, 0x1A1A1A,
    0x1A1A1A, 0x191919, 0x181818, 0x181818, 0x171717, 0x171717, 0x161616, 0x161616, 0x151515, 0x151515, 0x141414,
    0x141414, 0x131313, 0x121212, 0x121212, 0x111111, 0x111111, 0x101010, 0x101010, 0xF0F0F,  0xF0F0F,  0xE0E0E,
    0xE0E0E,  0xD0D0D,  0xD0D0D,  0xC0C0C,  0xB0B0B,  0xB0B0B,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,  0xA0A0A,
    0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A,
    0xA0A0A, 0xA0A0A, 0xA0A0A, 0xA0A0A,
  }


};





// Save some element references for direct access
//<Save_References !Start!>
gslc_tsElemRef* ambTempTxt        = NULL;
gslc_tsElemRef* autoBtn           = NULL;
gslc_tsElemRef* autoScaleScrl     = NULL;
gslc_tsElemRef* autoScaleTxt      = NULL;
gslc_tsElemRef* avFrontTxt        = NULL;
gslc_tsElemRef* avLeftTxt         = NULL;
gslc_tsElemRef* avRearTxt         = NULL;
gslc_tsElemRef* avRightTxt        = NULL;
gslc_tsElemRef* backspaceBtn      = NULL;
gslc_tsElemRef* colorBackBtn      = NULL;
gslc_tsElemRef* colorList         = NULL;
gslc_tsElemRef* colorListScrl     = NULL;
gslc_tsElemRef* colorSelectBtn    = NULL;
gslc_tsElemRef* cursorBtn         = NULL;
gslc_tsElemRef* cursorOnTxt       = NULL;
gslc_tsElemRef* cursorTxt         = NULL;
gslc_tsElemRef* dataTxt_1         = NULL;
gslc_tsElemRef* dataTxt_10        = NULL;
gslc_tsElemRef* dataTxt_11        = NULL;
gslc_tsElemRef* dataTxt_12        = NULL;
gslc_tsElemRef* dataTxt_2         = NULL;
gslc_tsElemRef* dataTxt_3         = NULL;
gslc_tsElemRef* dataTxt_4         = NULL;
gslc_tsElemRef* dataTxt_5         = NULL;
gslc_tsElemRef* dataTxt_6         = NULL;
gslc_tsElemRef* dataTxt_7         = NULL;
gslc_tsElemRef* dataTxt_8         = NULL;
gslc_tsElemRef* dataTxt_9         = NULL;
gslc_tsElemRef* dateTimeTxt       = NULL;
gslc_tsElemRef* dateTxt           = NULL;
gslc_tsElemRef* defaultBtn        = NULL;
gslc_tsElemRef* deleteBtn         = NULL;
gslc_tsElemRef* deltaFLTxt        = NULL;
gslc_tsElemRef* deltaFRTxt        = NULL;
gslc_tsElemRef* deltaRLTxt        = NULL;
gslc_tsElemRef* deltaRRTxt        = NULL;
gslc_tsElemRef* frontLeft         = NULL;
gslc_tsElemRef* frontRight        = NULL;
gslc_tsElemRef* homeBtn           = NULL;
gslc_tsElemRef* logAmbTxt         = NULL;
gslc_tsElemRef* logBackBtn        = NULL;
gslc_tsElemRef* logDeleteNo       = NULL;
gslc_tsElemRef* logDeleteYes      = NULL;
gslc_tsElemRef* logList           = NULL;
gslc_tsElemRef* logLoadBtn        = NULL;
gslc_tsElemRef* logNameDateTxt    = NULL;
gslc_tsElemRef* logSaveBtn        = NULL;
gslc_tsElemRef* logScrl           = NULL;
gslc_tsElemRef* logTempTxt        = NULL;
gslc_tsElemRef* logTrackTxt       = NULL;
gslc_tsElemRef* maxTempBtn        = NULL;
gslc_tsElemRef* minTempBtn        = NULL;
gslc_tsElemRef* okBtn             = NULL;
gslc_tsElemRef* pgLogBtn          = NULL;
gslc_tsElemRef* pgPressBtn        = NULL;
gslc_tsElemRef* pgTempBtn         = NULL;
gslc_tsElemRef* pgThermalBtn      = NULL;
gslc_tsElemRef* pressGauge        = NULL;
gslc_tsElemRef* pressPauseBtn     = NULL;
gslc_tsElemRef* profileList       = NULL;
gslc_tsElemRef* profileScrl       = NULL;
gslc_tsElemRef* rearLeft          = NULL;
gslc_tsElemRef* rearRight         = NULL;
gslc_tsElemRef* resSCRL           = NULL;
gslc_tsElemRef* resTxt            = NULL;
gslc_tsElemRef* saveLoadBtn       = NULL;
gslc_tsElemRef* saveLoadProgBox   = NULL;
gslc_tsElemRef* saveLoadProgress  = NULL;
gslc_tsElemRef* tempGauge         = NULL;
gslc_tsElemRef* tempPauseBtn      = NULL;
gslc_tsElemRef* thermalPauseBtn   = NULL;
gslc_tsElemRef* thermalSettBtn    = NULL;
gslc_tsElemRef* timeTxt           = NULL;
gslc_tsElemRef* trackTempBtn      = NULL;
gslc_tsElemRef* trackTempTxt      = NULL;
gslc_tsElemRef* wakeBtn           = NULL;
gslc_tsElemRef* m_pElemKeyPadNum  = NULL;
//<Save_References !End!>

// Define debug message function
static int16_t DebugOut(char ch) {
  if (ch == (char)'\n') Serial.println("");
  else Serial.write(ch);
  return 0;
}

// ------------------------------------------------
// Callback Methods
// ------------------------------------------------
// Common Button callback
bool CbBtnCommon(void* pvGui, void *pvElemRef, gslc_teTouch eTouch, int16_t nX, int16_t nY)
{
  // Typecast the parameters to match the GUI and element types
  gslc_tsGui*     pGui     = (gslc_tsGui*)(pvGui);
  gslc_tsElemRef* pElemRef = (gslc_tsElemRef*)(pvElemRef);
  gslc_tsElem*    pElem    = gslc_GetElemFromRef(pGui, pElemRef);


  if ( eTouch == GSLC_TOUCH_UP_IN ) {
    screensaverTimer = currentMillis;
    // From the element's ID we can determine which button was pressed.
    switch (pElem->nId) {
//<Button Enums !Start!>
      case HOME_BTN:
        gslc_SetPageCur(&m_gui, PG_Home);
        break;
      case WAKE_BTN:
        gslc_SetPageCur(&m_gui, lastPageId);
        break;
      case PG_PRESS_BTN:
        gslc_SetPageCur(&m_gui, PG_Pressure);
        break;
      case PG_TEMP_BTN:
        gslc_SetPageCur(&m_gui, PG_Temp);
        break;
      case PG_THERMAL_BTN:
        gslc_SetPageCur(&m_gui, PG_Thermal);
        break;
      case PG_LOG_BTN:
        gslc_SetPageCur(&m_gui, PG_Log);
        break;
      case PRESS_PAUSE_BTN:
        if (pausePressure == false) {
          pausePressure = true;
        }
        else {
          pausePressure = false;
        }
        gslc_ElemSetRedraw(&m_gui, pressPauseBtn, GSLC_REDRAW_FULL);
        break;
      case TEMP_PAUSE_BTN:
        if (pauseTemp == false) {
          pauseTemp = true;
        }
        else {
          pauseTemp = false;
        }
        gslc_ElemSetRedraw(&m_gui, tempPauseBtn, GSLC_REDRAW_FULL);
        break;
      case AUTO_BTN:
        if (autoScale == false) {
          DefaultTemp = false;
          autoScale = true;
        }
        else {
          autoScale = false;
        }
        gslc_ElemSetRedraw(&m_gui, autoBtn, GSLC_REDRAW_FULL);
        break;
      case THERMAL_PAUSE_BTN:
        if (pauseThermal == false) {
          pauseThermal = true;
        }
        else {
          pauseThermal = false;
        }
        gslc_ElemSetRedraw(&m_gui, thermalPauseBtn, GSLC_REDRAW_FULL);
        break;
      case MIN_TEMP_BTN:
        pauseThermal = true;
        // Clicked on edit field, so show popup box and associate with this text field
        gslc_ElemXKeyPadInputAsk(&m_gui, m_pElemKeyPadNum, E_POP_KEYPAD_NUM, minTempBtn);
        break;
      case DEFAULT_BTN:
        autoScale = false ;
        DefaultTemp = true;
        SetTempScale();
        gslc_ElemSetRedraw(&m_gui, autoBtn, GSLC_REDRAW_FULL);
        break;
      case MAX_TEMP_BTN:
        pauseThermal = true;
        // Clicked on edit field, so show popup box and associate with this text field
        gslc_ElemXKeyPadInputAsk(&m_gui, m_pElemKeyPadNum, E_POP_KEYPAD_NUM, maxTempBtn);
        break;
      case THERMAL_SETT_BTN:
        pauseThermal = true;
        gslc_PopupShow(&m_gui, THERMAL_SETTINGS, true);
        break;
      case TRACK_TEMP_BTN:
        snprintf(trackTempBuf, MAX_STR, "Track Temp:%.0f'C", cursorTemp);
        gslc_ElemSetTxtStr(&m_gui, trackTempTxt , trackTempBuf);
        break;
      case FRONT_LEFT:
        SetWheelPos(FrontLeft);
        break;
      case FRONT_RIGHT:
        SetWheelPos(FrontRight);
        break;
      case REAR_LEFT:
        SetWheelPos(RearLeft);
        break;
      case REAR_RIGHT:
        SetWheelPos(RearRight);
        break;
      case OK_BTN:
        counter ++;
        SaveMeasurement (counter);
        ShowStats (counter);
        ShowLogInfo (false);
        if (counter >= 11) {
          counter = -1;
        }
        break;
      case BACKSPACE_BTN:
        if (counter >= 0) {
          DeleteMeasurement (counter);
          counter --;
        }
        ShowLogInfo (false);
        break;
      case DELETE_BTN:
        gslc_PopupShow(&m_gui, CONFIRM_DELETE, true);
        break;
      case SAVE_LOAD_BTN:
        gslc_PopupShow(&m_gui, LOG_SAVE_LOAD, true);
        break;
      case CURSOR_BTN:
        // TODO Add code for Toggle button ON/OFF state
        if (gslc_ElemXTogglebtnGetState(&m_gui, cursorBtn)) {
          cursorOn = true;
          gslc_ElemSetTxtStr(&m_gui, cursorOnTxt , "On");
        }
        else {
          cursorOn = false;
          gslc_ElemSetTxtStr(&m_gui, cursorOnTxt , "Off");
        }
        break;
      case COLOR_BACK_BTN:
        gslc_PopupHide(&m_gui);
        pauseThermal = false;
        break;
      case COLOR_SELECT_BTN:
        gslc_PopupHide(&m_gui);
        thermalCol = thermalSel;
        pauseThermal = false;
        break;
      case LOG_SAVE_BTN:
        if (strcmp (logFolder, "") != 0 && strcmp (logFolder, "") != 0) {
          snprintf(logPath, MAX_STR, "/%s/%s.txt", logFolder, logName);
          saveLogFile(SD, logPath);
        }
        break;
      case LOG_LOAD_BTN:
        if (strcmp (logFolder, "") != 0 && strcmp (logFolder, "") != 0) {
          snprintf(logPath, MAX_STR, "/%s/%s.txt", logFolder, logName);
          openLogFile (SD, logPath);
          ShowLogInfo (true);
        }
        break;
      case LOG_BACK_BTN:
        ShowFileProgress(0);
        gslc_PopupHide(&m_gui);
        break;
      case LOG_DEL_YES:
        ResetLog();
        ShowLogInfo (false);
        gslc_PopupHide(&m_gui);
        break;
      case LOG_DEL_NO:
        gslc_PopupHide(&m_gui);
        break;
//<Button Enums !End!>
      default:
        break;
    }
  }
  return true;
}
//<Checkbox Callback !Start!>
//<Checkbox Callback !End!>
// KeyPad Input Ready callback
bool CbKeypad(void* pvGui, void *pvElemRef, int16_t nState, void* pvData)
{
  gslc_tsGui*     pGui     = (gslc_tsGui*)pvGui;
  gslc_tsElemRef* pElemRef = (gslc_tsElemRef*)(pvElemRef);
  gslc_tsElem*    pElem    = gslc_GetElemFromRef(pGui, pElemRef);

  // From the pvData we can get the ID element that is ready.
  int16_t nTargetElemId = gslc_ElemXKeyPadDataTargetIdGet(pGui, pvData);
  if (nState == XKEYPAD_CB_STATE_DONE) {
    // User clicked on Enter to leave popup
    // - If we have a popup active, pass the return value directly to
    //   the corresponding value field
    switch (nTargetElemId) {
//<Keypad Enums !Start!>

      case MIN_TEMP_BTN:
        gslc_ElemXKeyPadInputGet(pGui, minTempBtn, pvData);
        pauseThermal = false;
        MINTEMP = atoi (gslc_ElemGetTxtStr (pGui, minTempBtn)) ;
        gslc_PopupHide(&m_gui);

        break;
      case MAX_TEMP_BTN:
        gslc_ElemXKeyPadInputGet(pGui, maxTempBtn, pvData);
        MAXTEMP = atoi (gslc_ElemGetTxtStr (pGui, maxTempBtn)) ;
        gslc_PopupHide(&m_gui);
        pauseThermal = false;
        break;
//<Keypad Enums !End!>
      default:
        break;
    }
  } else if (nState == XKEYPAD_CB_STATE_CANCEL) {
    // User escaped from popup, so don't update values
    gslc_PopupHide(&m_gui);
    pauseThermal = false;
  }
  return true;
}
//<Spinner Callback !Start!>
//<Spinner Callback !End!>
bool CbListbox(void* pvGui, void* pvElemRef, int16_t nSelId)
{
  gslc_tsGui*     pGui     = (gslc_tsGui*)(pvGui);
  gslc_tsElemRef* pElemRef = (gslc_tsElemRef*)(pvElemRef);
  gslc_tsElem*    pElem    = gslc_GetElemFromRef(pGui, pElemRef);
  char            acTxt[MAX_STR + 1];

  if (pElemRef == NULL) {
    return false;
  }

  // From the element's ID we can determine which listbox was active.
  switch (pElem->nId) {
//<Listbox Enums !Start!>

    case COLOR_LIST:
      if (nSelId != XLISTBOX_SEL_NONE) {
        gslc_ElemXListboxGetItem(&m_gui, pElemRef, nSelId, acTxt, MAX_STR);
      }
      thermalSel = nSelId;
      SetColorPreview(147, 112, 16, thermalSel);
      break;
    case PROFILE_LIST:
      if (nSelId != XLISTBOX_SEL_NONE) {
        gslc_ElemXListboxGetItem(&m_gui, pElemRef, nSelId, logFolder, MAX_STR);
      }
      break;
    case LOG_LIST:
      if (nSelId != XLISTBOX_SEL_NONE) {
        gslc_ElemXListboxGetItem(&m_gui, pElemRef, nSelId, logName, MAX_STR);
      }
      break;
//<Listbox Enums !End!>
    default:
      break;
  }
  return true;
}
// Scanner drawing callback function
// - This is called when E_ELEM_SCAN is being rendered
bool CbDrawScanner(void* pvGui, void* pvElemRef, gslc_teRedrawType eRedraw)
{
  int nInd;


  // Typecast the parameters to match the GUI and element types
  gslc_tsGui*     pGui     = (gslc_tsGui*)(pvGui);
  gslc_tsElemRef* pElemRef = (gslc_tsElemRef*)(pvElemRef);
  gslc_tsElem*    pElem    = gslc_GetElemFromRef(pGui, pElemRef);


  // Create shorthand variables for the origin
  int16_t  nX = pElem->rElem.x;
  int16_t  nY = pElem->rElem.y;
  // Draw the background
  gslc_tsRect rInside = pElem->rElem;
  rInside = gslc_ExpandRect(rInside, 0, 0);
  gslc_DrvDrawFillRoundRect (pGui, rInside, 5, pElem->colElemFill);
  // Enable localized clipping
  gslc_SetClipRect(pGui, &rInside);

  //TODO - Add your drawing graphic primitives
  if (pElemRef == pressPauseBtn) {
    if (pausePressure == false) {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/pause.bmp", rInside.x, rInside.y);
    } else {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/play.bmp", rInside.x, rInside.y);
    }
  }

  if (pElemRef == tempPauseBtn) {
    if (pauseTemp == false) {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/pause.bmp", rInside.x, rInside.y);
    } else {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/play.bmp", rInside.x, rInside.y);
    }
  }

  if (pElemRef == thermalPauseBtn) {
    if (pauseThermal == false) {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/pause.bmp", rInside.x, rInside.y);
    } else {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/play.bmp", rInside.x, rInside.y);
    }
  }

  if (pElemRef == autoBtn) {
    if (autoScale == false) {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/autoInactive.bmp", rInside.x, rInside.y);
    } else {
      gslc_DrvDrawBmp24FromSD(&m_gui, "/autoActive.bmp", rInside.x, rInside.y);
    }
  }

  if (pElemRef == defaultBtn) {
    SetColorPreview (112, 210, 20, thermalCol);
  }
  if (pElemRef == frontLeft) {
    GetTireColor ( FrontLeft, dataFieldInt[2], dataFieldInt[1], dataFieldInt[0]);
  }
  if (pElemRef == rearLeft) {
    GetTireColor ( RearLeft, dataFieldInt[5], dataFieldInt[4], dataFieldInt[3]);
  }
  if (pElemRef == rearRight) {
    GetTireColor ( RearRight, dataFieldInt[6], dataFieldInt[7], dataFieldInt[8]);
  }
  if (pElemRef == frontRight) {
    GetTireColor ( FrontRight, dataFieldInt[9], dataFieldInt[10], dataFieldInt[11]);
  }
  // Disable clipping region
  gslc_SetClipRect(pGui, NULL);

  // Draw the frame
  gslc_DrawFrameRoundRect(pGui, pElem->rElem, 5, pElem->colElemFrame);

  // Clear the redraw flag
  gslc_ElemSetRedraw(&m_gui, pElemRef, GSLC_REDRAW_NONE);

  return true;
}

// Callback function for when a slider's position has been updated
bool CbSlidePos(void* pvGui, void* pvElemRef, int16_t nPos)
{
  gslc_tsGui*     pGui     = (gslc_tsGui*)(pvGui);
  gslc_tsElemRef* pElemRef = (gslc_tsElemRef*)(pvElemRef);
  gslc_tsElem*    pElem    = gslc_GetElemFromRef(pGui, pElemRef);
  int16_t         nVal;
  gslc_tsElemRef* pElemRefTmp = NULL;

  // From the element's ID we can determine which slider was updated.
  switch (pElem->nId) {
//<Slider Enums !Start!>

    case COLOR_LIST_SCRL:
      // Fetch the slider position
      nVal = gslc_ElemXSliderGetPos(pGui, colorListScrl);
      // Update the textbox scroll position
      pElemRefTmp = gslc_PageFindElemById(pGui, THERMAL_SETTINGS, COLOR_LIST);
      gslc_ElemXListboxSetScrollPos(pGui, pElemRefTmp, nVal);
      break;
    case AUTO_SCALE_SCRL:
      // Fetch the slider position
      nVal = gslc_ElemXSliderGetPos(pGui, autoScaleScrl);
      scaleRange = nVal;
      snprintf(scaleRangeBuf, 2, "%i", nVal);
      gslc_ElemSetTxtStr(&m_gui, autoScaleTxt , scaleRangeBuf);
      break;
    case PROFILE_SCRL:
      // Fetch the slider position
      nVal = gslc_ElemXSliderGetPos(pGui, profileScrl);
      pElemRefTmp = gslc_PageFindElemById(pGui, LOG_SAVE_LOAD, PROFILE_LIST);
      gslc_ElemXListboxSetScrollPos(pGui, pElemRefTmp, nVal);
      break;
    case LOG_SCRL:
      // Fetch the slider position
      nVal = gslc_ElemXSliderGetPos(pGui, logScrl);
      pElemRefTmp = gslc_PageFindElemById(pGui, LOG_SAVE_LOAD, LOG_LIST);
      gslc_ElemXListboxSetScrollPos(pGui, pElemRefTmp, nVal);
      break;
    case RES_SCRL:
      // Fetch the slider position
      nVal = gslc_ElemXSliderGetPos(pGui, resSCRL);
      SetResolution(nVal);
      break;
//<Slider Enums !End!>
    default:
      break;
  }

  return true;
}
//<Tick Callback !Start!>
//<Tick Callback !End!>

void setup()
{
  // ------------------------------------------------
  // Initialize
  // ------------------------------------------------
  Serial.begin(9600);
  // Wait for USB Serial
  //delay(1000);  // NOTE: Some devices require a delay after Serial.begin() before serial port can be used

  gslc_InitDebug(&DebugOut);
  amg.begin();
  probe.begin();
  rtc.begin();
  //rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  refreshTimer = millis();
  screensaverTimer = millis();


  // ------------------------------------------------
  // Create graphic elements
  // ------------------------------------------------

  InitGUIslice_gen();
  gslc_ElemSetGlowEn(&m_gui, dataTxt_1, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_2, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_3, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_4, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_5, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_6, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_7, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_8, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_9, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_10, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_11, true);
  gslc_ElemSetGlowEn(&m_gui, dataTxt_12, true);
  gslc_ElemSetGlow(&m_gui, dataTxt_1, true);
  gslc_ElemSetVisible(&m_gui, logNameDateTxt, false);
  gslc_ElemSetVisible(&m_gui, logAmbTxt, false);
  gslc_ElemSetVisible(&m_gui, logTrackTxt, false);
}

// -----------------------------------
// Main event loop
// -----------------------------------
void loop()
{
  // ------------------------------------------------
  // General
  // ------------------------------------------------
  
  currentMillis = millis();
  DateTime now = rtc.now();

  // ------------------------------------------------
  // Update Base Page Headers
  // ------------------------------------------------


  if (gslc_GetPageCur(&m_gui) == PG_ScreenSaver) {
    char Time [] = "hh:mm";
    gslc_ElemSetTxtStr(&m_gui, timeTxt, (now.toString(Time)));
    char Date [] = "DDD, DD/MM/YYYY";
    gslc_ElemSetTxtStr(&m_gui, dateTxt, (now.toString(Date)));
  }
  else {
    ambTemp = amg.readThermistor();
    if (ambTemp != -127) {
      snprintf(ambTempBuf, MAX_STR, "Amb Temp:%d'C", ambTemp);
      gslc_ElemSetTxtStr(&m_gui, ambTempTxt, ambTempBuf);
    }
    char dateTime[] = "DDD, DD/MM/YYYY hh:mm";
    gslc_ElemSetTxtStr(&m_gui, dateTimeTxt, (now.toString(dateTime)));
    if (currentMillis - screensaverTimer >= 1 * Minutes) {
      lastPageId = gslc_GetPageCur(&m_gui) ;
      gslc_PopupHide(&m_gui);
      gslc_SetPageCur(&m_gui, PG_ScreenSaver);
    }
  }


  // ------------------------------------------------
  // Update GUI Elements
  // ------------------------------------------------

  if (gslc_GetPageCur(&m_gui) == PG_Pressure && pausePressure == false) {
    if (currentMillis - refreshTimer >= 1 * Halfseconds) {
      GetPressure();
      snprintf(pressureBuf, MAX_STR, "%.3f", gaugePressure);
      gslc_ElemSetTxtStr(&m_gui, pressGauge, pressureBuf);
      gslc_ElemXRingGaugeSetVal(&m_gui, pressGauge, gaugeVal);
      refreshTimer = currentMillis;
    }
  }

   if (gslc_GetPageCur(&m_gui) == PG_Temp && pauseTemp == false) {
    if (currentMillis - refreshTimer >= 1 * Halfseconds) {
      GetTemperature();
      snprintf(tempBuf, MAX_STR, "%.2f'C", probeTemp);
      gslc_ElemSetTxtStr(&m_gui, tempGauge, tempBuf);
      gslc_ElemXRingGaugeSetVal(&m_gui, tempGauge, gaugeVal);
      refreshTimer = currentMillis;
    }
  }


  if (gslc_GetPageCur(&m_gui) == PG_Log) {
    if (isnan(probeTemp)) {
      if ((gslc_ElemGetVisible(&m_gui, logTempTxt) == true)) {
        gslc_ElemSetVisible(&m_gui, logTempTxt, false);
      }
    }
    else {
      if (gslc_ElemGetVisible(&m_gui, logTempTxt) == false) {
        gslc_ElemSetVisible(&m_gui, logTempTxt, true);
      }
      if (currentMillis - refreshTimer >= 1 * Halfseconds) {
        GetTemperature();
        snprintf(tempBuf, MAX_STR, "%.2f'C", probeTemp);
        gslc_ElemSetTxtStr(&m_gui, logTempTxt, tempBuf);
        refreshTimer = currentMillis;
      }
    }
  }



  if (gslc_GetPageCur(&m_gui) == PG_Thermal && pauseThermal == false) {
      amg.readPixels(pixels);
      interpolate_image(pixels, AMG_ROWS, AMG_COLS, dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS);
      drawpixels(dest_2d, INTERPOLATED_ROWS, INTERPOLATED_COLS, boxWidth, boxHeight, false);
  }


  // ------------------------------------------------
  // Periodically call GUIslice update function
  // ------------------------------------------------
  gslc_Update(&m_gui);

}


// ----------------------------------------------------------------------------------------------------
// Thermal Camera Functions
// ----------------------------------------------------------------------------------------------------
void drawpixels(float * p, uint8_t rows, uint8_t cols, uint8_t boxWidth, uint8_t boxHeight, boolean showVal) { //From Adafruit example
  for (int y = 0; y < rows; y++) {
    for (int x = 0; x < cols; x++) {
      float val = get_point(p, rows, cols, x, y);
      if (val >= MAXTEMP) colorTemp = MAXTEMP;
      else if (val <= MINTEMP) colorTemp = MINTEMP;
      else colorTemp = val;
      uint16_t colorIndex = map(colorTemp * 1000, MINTEMP * 1000, MAXTEMP * 1000, 0, 432);
      colorIndex = constrain(colorIndex, 0, 432);
      gslc_tsRect rCamRect = {
        60 + boxWidth * x,
        20 + boxHeight * y,
        boxWidth,
        boxHeight
      };
      uint32_t     nCamColor_HEX = colorPallete [thermalCol] [colorIndex];
      gslc_tsColor nCamCol_rgb;
      nCamCol_rgb.r = ((nCamColor_HEX >> 16) & 0xFF);
      nCamCol_rgb.g = ((nCamColor_HEX >> 8) & 0xFF);
      nCamCol_rgb.b = ((nCamColor_HEX) & 0xFF) ;
      gslc_DrvDrawFillRect(&m_gui, rCamRect, nCamCol_rgb);
    }
    if (cursorOn == true) {
      SetCursor ();
    }
  }
  if (autoScale == true) {
    SetTempScale();
  }

}

void SetTempScale() {
  if (DefaultTemp == true) {
    MINTEMP = 20;
    MAXTEMP = 30;
  }
  else {
    float val = 0.0;
    for (int i = 0; i < 64; i++) {
      val = val + pixels[i];
    }
    val = val / 64.0;
    MINTEMP = val - scaleRange;
    MAXTEMP = val + scaleRange;
    snprintf(minTempBuf, 3, "%d", MINTEMP);
    gslc_ElemSetTxtStr(&m_gui, minTempBtn  , minTempBuf);
    snprintf(maxTempBuf, 3, "%d", MAXTEMP);
    gslc_ElemSetTxtStr(&m_gui, maxTempBtn, maxTempBuf);
  }
}

void SetColorPreview (int preview_x, int preview_y, int preview_h, int pallete ) {
  if ((pallete < 0) | (pallete > 6) ) {
    for (int j = 0; j < 150; j++) {
      gslc_DrawLineV (&m_gui, preview_x + j, preview_y, preview_h, GSLC_COL_WHITE);
    }
  }
  else {
    for (int j = 0; j < 150; j++) {
      colorMap = map (j, 0, 150, 0, 432);
      uint32_t     nColorMap_HEX = colorPallete [pallete] [colorMap];
      gslc_tsColor nColorMap_rgb;
      nColorMap_rgb.r = ((nColorMap_HEX >> 16) & 0xFF);
      nColorMap_rgb.g = ((nColorMap_HEX >> 8) & 0xFF);
      nColorMap_rgb.b = ((nColorMap_HEX) & 0xFF) ;
      gslc_DrawLineV (&m_gui, preview_x + j, preview_y, preview_h, nColorMap_rgb);
    }
  }
}

void SetResolution (int resolution) {
  if (resolution == 0) {      //Low Resolution
    gslc_ElemSetTxtStr(&m_gui, resTxt , "Low");
    INTERPOLATED_COLS = 18;
    INTERPOLATED_ROWS = 15;
    boxWidth = 14;
    boxHeight = 12;
  }
  else if (resolution == 1) { //Medium Resolution
    gslc_ElemSetTxtStr(&m_gui, resTxt , "Medium");
    INTERPOLATED_COLS = 36;
    INTERPOLATED_ROWS = 36;
    boxWidth = 7;
    boxHeight = 5;
  }
  else if (resolution == 2) { //High Resolution
    gslc_ElemSetTxtStr(&m_gui, resTxt , "High");
    INTERPOLATED_COLS = 63;
    INTERPOLATED_ROWS = 60;
    boxWidth =  4;
    boxHeight = 3;
  }
}

void SetCursor () {
  cursorTemp = (pixels [28] + pixels [29] + pixels [36] + pixels [37]) / 4;
  snprintf(cursorTempBuf, 7, "%.2f", cursorTemp);
  for (int j = 0; j < 3; j++) {
    gslc_DrawLineH (&m_gui, 171, 109 + j, 30, GSLC_COL_WHITE);
    gslc_DrawLineV (&m_gui, 185 + j, 95, 30, GSLC_COL_WHITE);
  }
  gslc_ElemSetTxtStr(&m_gui, cursorTxt , cursorTempBuf);
}



// ---------------------------------------------------------------------------------------
// Data Log Functions
// ---------------------------------------------------------------------------------------
void GetTireColor (uint8_t wheelPos, int16_t outside, int16_t middle, int16_t inside) {
  unsigned int tireColor;
  int tire_x;
  int tire_y;
  int i = 4;
  int n = 4;
  int insideTempCol = map (constrain (inside / 100, 15, 120), 15, 120, 0, 432);
  int middleTempCol = map (constrain (middle / 100, 15, 120), 15, 120, 0, 432);
  int outsideTempCol = map (constrain (outside / 100, 15, 120), 15, 120, 0, 432);
  switch (wheelPos) {
    case FrontLeft:
      tire_x = 120;
      tire_y = 40;
      break;
    case RearLeft:
      tire_x = 120;
      tire_y = 170;
      break;
    case RearRight:
      tire_x = 220;
      tire_y = 170;
      break;
    case FrontRight:
      tire_x = 220;
      tire_y = 40;
      break;
  }
  for (int j = 0; j < 30; j++) {
    if (j <= 5) {
      tireColor = outsideTempCol;
    }
    else if ((j >= 6) & (j <= 11)) {
      tireColor = outsideTempCol + ((middleTempCol - outsideTempCol) / 6) * (j - 6) ;
    }
    else if ((j >= 12) & (j <= 17)) {
      tireColor = middleTempCol;
    }
    else if ((j >= 18) & (j <= 23)) {
      tireColor = middleTempCol + ((insideTempCol - middleTempCol) / 6) * (j - 17) ;
    }
    else if (j >= 24) {
      tireColor = insideTempCol;
    }
    uint32_t nTireColor_HEX = colorPallete [1] [tireColor];
    gslc_tsColor nTireColor_rgb;
    nTireColor_rgb.r = ((nTireColor_HEX >> 16) & 0xFF);
    nTireColor_rgb.g = ((nTireColor_HEX >> 8) & 0xFF);
    nTireColor_rgb.b = ((nTireColor_HEX) & 0xFF) ;
    gslc_DrawLineV (&m_gui, tire_x + j , tire_y + i , 50 - (i * 2), nTireColor_rgb);
    if (j < 4) {
      i --;
    }
    else if (j >= 25) {
      i++;
    }
  }
}

void SetTireColor() {
  gslc_tsElemRef* Tire[] = {
    frontLeft,
    frontRight,
    rearLeft,
    rearRight,
  };
  for (uint8_t i = 0; i < 4; i++) {
    gslc_ElemSetRedraw(&m_gui, Tire[i], GSLC_REDRAW_FULL);
  }
}

void openLogFile(fs::FS & fs, const char * path) {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
    logAmbTxt,
    logTrackTxt,
  };
  ResetLog();
  File file = fs.open(path);
  while (file.available()) {
    for (int i = 0; i < numberLogLines; i++) {
      String list = file.readStringUntil('\n');

      if (i < 14) {
        const char* listConv = list.c_str();
        gslc_ElemSetTxtStr(&m_gui, (dataField[i]) , listConv);
      }
      else {
        dateBuf = list.c_str();
      }
      delay(50);
      ShowFileProgress (i);
    }
    file.close();

  }
  snprintf(LogInfoBuf, MAX_STR, "%s, %s: %s", logFolder, logName, dateBuf);
  gslc_ElemSetTxtStr(&m_gui, logNameDateTxt, LogInfoBuf);
  dataConvertToInt ();
  ShowStats (12);
}

void saveLogFile (fs::FS & fs, const char * path) {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
    ambTempTxt,
    trackTempTxt,
    dateTimeTxt
  };
  fs.remove(path);
  File file = fs.open(path, FILE_WRITE);
  for (int i = 0; i < numberLogLines; i++) {
    file.print(gslc_ElemGetTxtStr(&m_gui, (dataField[i])));
    file.print("\n");
    delay(50);
    ShowFileProgress (i);
  }
  file.close();
}

void ShowFileProgress (uint8_t progress) {
  gslc_ElemXProgressSetVal(&m_gui, saveLoadProgress, progress);
  gslc_Update(&m_gui);
}

void ShowLogInfo (bool loadLogInfo) {
  if (loadLogInfo == true) {
    gslc_ElemSetVisible(&m_gui, logNameDateTxt, true);
    gslc_ElemSetVisible(&m_gui, logAmbTxt, true);
    gslc_ElemSetVisible(&m_gui, logTrackTxt, true);
  }
  else {
    gslc_ElemSetVisible(&m_gui, logNameDateTxt, false);
    gslc_ElemSetVisible(&m_gui, logAmbTxt, false);
    gslc_ElemSetVisible(&m_gui, logTrackTxt, false);
  }
}

void SaveMeasurement (uint8_t dataPos) {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
  };
  gslc_ElemSetTxtStr(&m_gui, (dataField[dataPos]) , tempBuf);
  gslc_ElemSetTxtCol(&m_gui, (dataField[dataPos]) , GSLC_COL_YELLOW);
  gslc_ElemSetGlow(&m_gui, (dataField [dataPos]), false);
  if (counter < 11) {
    gslc_ElemSetTxtCol(&m_gui, (dataField[dataPos + 1]) , GSLC_COL_WHITE);
    gslc_ElemSetGlow(&m_gui, (dataField[dataPos + 1]), true);
  }
  if (dataPos < 3) {
    gslc_ElemSetRedraw(&m_gui, frontLeft, GSLC_REDRAW_FULL);
  }
  if (dataPos >= 3 && dataPos < 6) {
    gslc_ElemSetRedraw(&m_gui, rearLeft, GSLC_REDRAW_FULL);
  }
  if (dataPos >= 6 && dataPos < 9) {
    gslc_ElemSetRedraw(&m_gui, rearRight, GSLC_REDRAW_FULL);
  }
  if (dataPos >= 9) {
    gslc_ElemSetRedraw(&m_gui, frontRight, GSLC_REDRAW_FULL);
  }
  if (dataPos == 11) {
    gslc_ElemSetTxtCol(&m_gui, (dataField[0]) , GSLC_COL_WHITE);
    gslc_ElemSetGlow(&m_gui, (dataField[0]), true);
  }
  dataConvertToInt ();
}

void DeleteMeasurement (uint8_t dataPos) {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
  };
  gslc_ElemSetTxtStr(&m_gui, (dataField[dataPos + 1]) , nullnullval);
  gslc_ElemSetTxtCol(&m_gui, (dataField[dataPos]) , GSLC_COL_WHITE);
  gslc_ElemSetGlow(&m_gui, (dataField [dataPos]), true);
  gslc_ElemSetTxtCol(&m_gui, (dataField[dataPos + 1]) , GSLC_COL_YELLOW);
  gslc_ElemSetGlow(&m_gui, (dataField[dataPos + 1]), false);
}

void ResetLog() {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
    avFrontTxt,
    avLeftTxt,
    avRearTxt,
    avRightTxt,
    deltaFLTxt,
    deltaRLTxt,
    deltaRRTxt,
    deltaFRTxt,
  };
  for (int i = 0; i < 20; i++) {
    if (i < 12) {
      gslc_ElemSetTxtStr(&m_gui, (dataField[i]) , nullnullval);
      gslc_ElemSetTxtCol(&m_gui, (dataField[i]) , GSLC_COL_YELLOW);
      gslc_ElemSetGlow(&m_gui, (dataField [i]), false);
    }
    else if (i > 12 && i < 16) {
      gslc_ElemSetTxtStr(&m_gui, (dataField[i]) , "&---.--");
    }
    else {
      gslc_ElemSetTxtStr(&m_gui, (dataField[i]) , "$---.--");
    }
  }
  gslc_ElemSetTxtCol(&m_gui, (dataField[0]) , GSLC_COL_WHITE);
  gslc_ElemSetGlow(&m_gui, (dataField [0]), true);
  dataConvertToInt ();
  counter = -1;
}

void dataConvertToInt () {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
  };
  for (int i = 0; i < 12; i++) {
    if (atoi(gslc_ElemGetTxtStr(&m_gui, dataField[i])) != 0) {
      dataFieldInt[i] = atof (gslc_ElemGetTxtStr(&m_gui, dataField[i])) * 100;
    }
    else {
      dataFieldInt[i] = 0;
    }
  }
}

void GetStats () {
  uint8_t j = 0;
  for (uint8_t i = 0; i < 4; i++) {
    if (dataFieldInt [j] < dataFieldInt [j + 1] && dataFieldInt [j] < dataFieldInt [j + 2]) {
      cornerLowTemp[i] = dataFieldInt [j];
    }
    else if (dataFieldInt [j + 1] < dataFieldInt [j + 2]) {
      cornerLowTemp[i] = dataFieldInt [j + 1];
    }
    else {
      cornerLowTemp[i] = dataFieldInt [j + 2];
    }
    if (dataFieldInt [j] > dataFieldInt [j + 1] && dataFieldInt [j] > dataFieldInt [j + 2]) {
      cornerHighTemp[i] = dataFieldInt [j];
    }
    else if (dataFieldInt [j + 1] > dataFieldInt [j + 2]) {
      cornerHighTemp[i] = dataFieldInt [j + 1];
    }
    else {
      cornerHighTemp[i] = dataFieldInt [j + 2];
    }
    cornerDelta [i] = cornerHighTemp[i] - cornerLowTemp[i];
    cornerDelta [i] = cornerDelta [i] / 100;
    cornerAverage[i] = (dataFieldInt[j] + dataFieldInt[j + 1] + dataFieldInt[j + 2]);
    cornerAverage[i] = cornerAverage[i] / 3;
    j = j + 3;
  }
  j = 0;
  for (uint8_t i = 0; i < 4; i++) {
    if (i <= 2) {
      sideAverage [i] = cornerAverage [i] + cornerAverage [i + 1] ;
    }
    else if (i = 3) {
      sideAverage [i] = cornerAverage [i] + cornerAverage [0];
    }
    sideAverage [i] = sideAverage [i] / 200;

  }


}


void ShowStats(uint8_t dataPos) {
  GetStats();
  if (dataPos >= 2) {
    snprintf(deltaBuf, MAX_STR, "$%.2f", cornerDelta[FrontLeft]);
    gslc_ElemSetTxtStr (&m_gui, deltaFLTxt, deltaBuf);
  }
  if (dataPos >= 5) {
    snprintf(deltaBuf, MAX_STR, "$%.2f", cornerDelta[RearLeft]);
    gslc_ElemSetTxtStr (&m_gui, deltaRLTxt, deltaBuf);

    snprintf(averageBuf, MAX_STR, "&%.2f", sideAverage[Left]);
    gslc_ElemSetTxtStr(&m_gui, avLeftTxt, averageBuf);
  }
  if (dataPos >= 8) {
    snprintf(deltaBuf, MAX_STR, "$%.2f", cornerDelta[RearRight]);
    gslc_ElemSetTxtStr (&m_gui,  deltaRRTxt, deltaBuf);

    snprintf(averageBuf, MAX_STR, "&%.2f", sideAverage[Rear]);
    gslc_ElemSetTxtStr(&m_gui, avRearTxt, averageBuf);
  }
  if (dataPos >= 11) {
    snprintf(deltaBuf, MAX_STR, "$%.2f", cornerDelta[FrontRight]);
    gslc_ElemSetTxtStr (&m_gui, deltaFRTxt, deltaBuf);

    snprintf(averageBuf, MAX_STR, "&%.2f", sideAverage[Right]);
    gslc_ElemSetTxtStr(&m_gui, avRightTxt, averageBuf);

    snprintf(averageBuf, MAX_STR, "&%.2f", sideAverage[Front]);
    gslc_ElemSetTxtStr(&m_gui, avFrontTxt, averageBuf);
  }
}

void SetWheelPos (const uint8_t wheelPos) {
  gslc_tsElemRef* dataField[] = {
    dataTxt_1,
    dataTxt_2,
    dataTxt_3,
    dataTxt_4,
    dataTxt_5,
    dataTxt_6,
    dataTxt_7,
    dataTxt_8,
    dataTxt_9,
    dataTxt_10,
    dataTxt_11,
    dataTxt_12,
  };
  gslc_ElemSetTxtCol(&m_gui, (dataField[counter + 1]) , GSLC_COL_YELLOW);
  gslc_ElemSetGlow(&m_gui, (dataField [counter + 1]), false);
  gslc_ElemSetTxtCol(&m_gui, (dataField[(wheelPos * 3)]) , GSLC_COL_WHITE);
  gslc_ElemSetGlow(&m_gui, (dataField[wheelPos * 3]), true);
  counter = (wheelPos * 3) - 1;
}

void GetPressure () {
  abp.update();
  sensorPressure = abp.pressure();
  gaugePressure = (sensorPressure / 14.5038);
  gaugeVal = gaugePressure * 100;
}

void GetTemperature () {
  probeTemp = probe.getThermocoupleTemp();
  gaugeVal = probeTemp;
}
